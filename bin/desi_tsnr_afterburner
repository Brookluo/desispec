#!/usr/bin/env python
'''
Calculate stand alone tsnr tables for a given desispec prod.
'''

import os
import glob
import itertools
import argparse
import astropy.io.fits as fits
import numpy as np

from   desispec.io import read_sky
from   desispec.io import read_fiberflat
from   pathlib import Path
from   desispec.io.meta import findfile, specprod_root
from   desispec.calibfinder import CalibFinder
from   desispec.io import read_frame
from   desispec.io import read_fibermap
from   desispec.io.fluxcalibration import read_flux_calibration
from   desiutil.log import get_logger
from   desispec.tsnr import calc_tsnr2
from   astropy.table import Table, vstack
from   desiutil.depend import getdep

def parse(options=None):
    parser = argparse.ArgumentParser(description="Calculate template S/N ratio for exposures")
    parser.add_argument('--outdir', type = str, default = None, required=True,
                        help = 'Dir. to write to.')
    parser.add_argument('--prod', type = str, default = None, required=False,
                        help = 'Path to reduction, e.g. /global/cfs/cdirs/desi/spectro/redux/blanc/')
    parser.add_argument('--cameras', type = str, default = None, required=False,
                        help = 'Cameras to reduce (comma separated).')
    parser.add_argument('--summary_only', type = int, default = 0, required=False,
                        help = 'Write only summary file.')
    parser.add_argument('--expids', type = str, default = None, required=False,
                        help = 'Comma separated list of exp ids to be reduced.')
    parser.add_argument('--night', type = int, default = None, required=False,
                        help = 'Restrict to this night only.')
    args = None
    if options is None:
        args = parser.parse_args()
    else:
        args = parser.parse_args(options)
    return args


def main():
    log = get_logger()

    args=parse()
    if args.prod is None:
        args.prod = specprod_root()

    log.info('outdir = {}'.format(args.outdir))
    log.info('prod = {}'.format(args.prod))
    log.info('cameras = {}'.format(args.cameras))
    log.info('summary_only = {}'.format(args.summary_only))
    log.info('expids = {}'.format(args.expids))

    petals = np.arange(10).astype(str)

    if args.cameras is None:
        cameras = [x[0] + x[1] for x in itertools.product(['b', 'r', 'z'], petals.astype(np.str))]
    else:
        cameras = args.cameras.split(',')
    if args.expids is not None:
        expids = [np.int(x) for x in args.expids.split(',')]
    else:
        expids = None
    
    if args.night is None:
        args.night = '*'

    cframes = {}
    for cam in cameras:
        cframes[cam] = sorted(glob.glob('{}/exposures/{}/*/cframe-{}-*.fits'.format(args.prod, args.night, cam)))
 
    sci_frames = {}

    for cam in cameras:
        sci_frames[cam] = []
    
        for cframe in cframes[cam]:
            hdul = fits.open(cframe)
            hdr  = hdul[0].header 
        
            flavor = hdr['FLAVOR']
            prog = hdr['PROGRAM']
            expid = hdr['EXPID']
        
            if expids is not None:
                if expid not in expids:
                    continue
            
            if flavor == 'science':
                sci_frames[cam].append(cframe)

            hdul.close()
        
        log.info('{} science frames to reduce for {}.'.format(len(sci_frames[cam]), cam))

    summary  = list()
    for cam in cameras:
        for kk, x in enumerate(sci_frames[cam]):
            cframe = fits.open(x)
            hdr  = cframe[0].header
            if hdr['PROGRAM'].startswith('SV1'):
                night  = hdr['NIGHT']
                expid  = hdr['EXPID']
                camera = hdr['CAMERA']
                tileid = hdr['TILEID']

                calib  = findfile('fluxcalib', night=night, expid=expid,
                                  camera=camera, specprod_dir=args.prod)
            
                flat = cframe[0].header['FIBERFLT']

                if 'SPECPROD' in flat:
                    flat = flat.replace('SPECPROD', args.prod)
                
                elif 'SPCALIB' in flat:
                    flat = flat.replace('SPCALIB', getdep(hdr, 'DESI_SPECTRO_CALIB'))

                else:
                    raise ValueError('Failed on flat retrieval for {}.'.format(hdr))
                
                iin = x.replace('cframe', 'frame')
                sky = x.replace('cframe', 'sky')
                psf = sky.replace('sky', 'psf')
                out = args.outdir + '/tsnr/{}/{:08d}/tsnr-{}-{:08d}.fits'.format(night, expid, camera, expid)
                
                if (not args.summary_only) & os.path.exists(out):
                    continue
            
                Path(os.path.dirname(out)).mkdir(parents=True, exist_ok=True)
                
                frame=read_frame(iin)
                fiberflat=read_fiberflat(flat)
                fluxcalib=read_flux_calibration(calib)
                skymodel=read_sky(sky)
            
                results, alpha = calc_tsnr2(frame, fiberflat=fiberflat, skymodel=skymodel, fluxcalib=fluxcalib)

                if not args.summary_only:
                    # Write individual.
                    table=Table()
                
                    for k in results:
                        table[k] = results[k].astype(np.float32)

                    table['FIBER']       = frame.fibermap['FIBER']
                    table['TARGETID']    = frame.fibermap['TARGETID']
                
                    table.meta['NIGHT']  = night
                    table.meta['EXPID']  = expid
                    table.meta['TILEID'] = tileid
                    table.meta['CAMERA'] = camera
                    table.meta['TSNRALPH']  = alpha
                    table.meta['EXTNAME'] = 'TSNR2'

                    tmpfile = out+'.tmp'
                    table.write(tmpfile, format='fits', overwrite=True)
                    os.rename(tmpfile, out)

                    log.info('Successfully wrote {}.'.format(out))
                
                # Append to summary. 
                entry = dict()
                entry['NIGHT'] = np.int32(night)
                entry['EXPID'] = np.int32(expid)
                entry['TILEID'] = tileid
                entry['CAMERA'] = camera
                for key in results:
                    #- TSNR2_{TRACER}_{BAND} -> TSNR2_{TRACER}
                    short_key = '_'.join(key.split('_')[0:2])
                    entry[short_key]=np.median(results[key]).astype(np.float32)

                summary.append(entry)

                log.info('{} {:08d} {}: Reduced {} of {}.'.format(
                    night, expid, cam, kk, len(sci_frames[cam])))

        cframe.close()

    # Write summary files only if prod run, not comma sep. exp list. 
    if args.expids is None:
        colnames = list(summary[0].keys())
        summary = Table(rows=summary, names=colnames)
        summary.meta['EXTNAME'] = 'TSNR2'
        summary_outfile = args.outdir+'/tsnr_summary.fits'
        tmpfile = summary_outfile+'.tmp'
        summary.write(tmpfile, format='fits', overwrite=True)
        os.rename(tmpfile, summary_outfile)

        log.info('Successfully wrote {}'.format(summary_outfile))

    
if __name__ == '__main__':
    main()
