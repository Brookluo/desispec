#!/usr/bin/env python

"""
Work in progress testing by Stephen and AK
The catchup file should be a single night listed per row
No delimiters as it is only a single column (loaded as csv internally)
"""

import sys, os, glob, time, subprocess
import argparse
import psutil
import socket
import datetime
import desispec.io
import fitsio
from astropy.io import fits
import numpy as np

########################
### Helper Functions ###
########################
from desispec.desi_proc_dashboard import what_night_is_it, find_newexp, check_running

def get_catchup_nights(catchup_filename, docatchup=True):
    if docatchup and catchup_filename is not None and os.path.exists(catchup_filename):
        catchup = np.atleast_1d(np.loadtxt(catchup_filename, dtype=int)).tolist()
    else:
        catchup = []

    return catchup

def parse(options=None):
    parser = argparse.ArgumentParser(description="Perform daily processing of spectral"+
                                     "data using the pipeline. Can also catchup on"+
                                     "past nights.")
    # Runtime params
    parser.add_argument("-t","--pausetime", type=int, default=5, required=False,
                        help="Number of minutes to pause after 'nsubmit' "+
                             "submissions or after completing all known files.")
    parser.add_argument("-n", "--nsubmits", type=int, required=False, default=10,
                        help="Number of submissions to make to cori at a time."+
                             "After 'nsubmits,' the script will wait 'pausetime'"+
                             "minutes before submitting another 'nsubmits.'")

    parser.add_argument("--cameras", type=str, required=False,
                        help="Explicitly define the spectrographs for which you want"+
                             " to reduce the data. Should be a comma separated list."+
                             " Numbers only assumes you want to reduce R, B, and Z "+
                             "for that camera. Otherwise specify separately [BRZ|brz][0-9].")

    # File and dir defs
    parser.add_argument("-c", "--catchup-file", type=str, required=False,
                        help="Relative path+name for catchup file. Automatically "+
                             "triggers '--catchup' to be true.")
    parser.add_argument("-s", "--specprod", type=str, required=False,
                        help="Directory name where the output files should be saved.")
    parser.add_argument("-r", "--reduxdir", type=str, required=False,
                        help="Main reduction dir where specprod dir will reside.")

    # Code Flags
    parser.add_argument("--force-specprod", action="store_true",
                        help="Force the files to be written to custom SPECPROD "+
                             "even if user is desi.")
    parser.add_argument("--ignore-instances", action="store_true",
                        help="Allow script to run even if another instance is "+
                             "running. Use with care.")
    parser.add_argument("--ignore-cori-node", action="store_true",
                        help="Allow script to run on nodes other than cori21")
    parser.add_argument("--catchup", action="store_true",
                        help="Load in catch up file and rerun the listed nights")
    parser.add_argument("--scattered-light", action="store_true",
                        help="Pass scattered light command to desi_proc. Fits and removes scattered light.")
    parser.add_argument("--dry-run", action="store_true",
                        help="Perform a dry run where no jobs are actually submitted.")

    # Read in command line and return
    args = None
    if options is None:
        args = parser.parse_args()
    else:
        args = parser.parse_args(options)

    if args.catchup_file is not None:
        args.catchup = True


    return args


def main(args):

    #- Preflight checks
    if not args.ignore_cori_node and socket.gethostname() != 'cori21':
        print('This should only run on cori21')
        sys.exit(1)

    if not args.ignore_instances:
        running = check_running(proc_name='desi_dailyproc')
        if not running:
            print('OK to run')
        else:
            sys.exit(1)

    ########################
    ### Define io params ###
    ########################
    catchup_filename = 'none'
    if args.catchup:
        if args.catchup_file is None:
            catchup_filename = 'catchup_list.csv' # must be relative
                                                  # path from codedir
        else:
            catchup_filename = args.catchup_file
            
    if args.reduxdir is None:
        reduxdir = desispec.io.specprod_root() # directory for reductions
    else:
        reduxdir = args.reduxdir

    # Check if we should force the script to use
    # environment variable (for debugging)
    # Otherwise if it's the desi user, force to 'daily'
    # otherwise use whatever is defined with a default
    # of 'daily'
    if args.force_specprod:
        if args.specprod is None:
            if 'SPECPROD' not in os.environ.keys():
                os.environ['SPECPROD'] = 'daily'
            # else specprod already defined as desired
        else:
            os.environ['SPECPROD'] = args.specprod
    else:
        if str(os.environ['USER']).lower()=='desi':
            os.environ['SPECPROD'] = 'daily'
        elif args.specprod is None:
            if 'SPECPROD' not in os.environ.keys():
                os.environ['SPECPROD'] = 'daily'
            # else specprod already define
        else:
            os.environ['SPECPROD'] = args.specprod


    #########################
    ### Setup for Running ###
    #########################
    catchup = get_catchup_nights(catchup_filename,args.catchup)

    #- First identify exposures that are already processed
    known_exposures = set()

    tonight = what_night_is_it()
    for night in [tonight,] + catchup:
        fileglob = '{}/preproc/{}/*/preproc-*'.format(reduxdir, night)
        newexp = find_newexp(night, fileglob, known_exposures)
        print('{} exposures already processed on {}'.format(len(newexp), night))
        known_exposures.update(newexp)

    print('redux output to {}'.format(reduxdir))
    sys.stdout.flush()


    ###############################                                                                                                                         
    ### Define desi_proc params ###                                                                                                                             
    ############################### 
    cmd_base = 'desi_proc'
    cmd_base += ' --batch'
    cmd_base += ' --traceshift'
    if args.scattered_light:
        cmd_base += ' --scattered-light'
    if args.cameras is not None:
        args.cameras = args.cameras.strip(' \t')
        cmd_base += ' --cameras {}'.format(args.cameras)

                        
    ##################################
    ### Run until something breaks ###
    ##################################
    while True:
        tonight = what_night_is_it()
        catchup = get_catchup_nights(catchup_filename,args.catchup)
        for night in [tonight,] + catchup:
            print('{} Checking for new files on {}'.format(time.asctime(), night))
            fileglob = '{}/{}/*/desi-*.fits.fz'.format(
                os.getenv('DESI_SPECTRO_DATA'), night)

            newexp = find_newexp(night, fileglob, known_exposures)
            if len(newexp) > 0:
                print('{}  {} new files found'.format(time.asctime(), len(newexp)))
                if args.dry_run:
                    print("\n\n\n\tDry run, nothing submitted.")
                nsubmit = 0
                for night, expid in sorted(newexp):
                    known_exposures.add( (night, expid) )

                    #- skip ZEROs for now
                    rawfile = desispec.io.findfile('raw', night, expid)
                    ### hdr = fitsio.read_header(rawfile, 1)
                    hdr = fits.getheader(rawfile, 1)
                    if 'OBSTYPE' in hdr and hdr['OBSTYPE'].strip() == 'ZERO':
                        print('Skipping OBSTYPE=ZERO exposure {}/{}'.format(night, expid))
                        continue
                    #if 'OBSTYPE' in hdr and hdr['OBSTYPE'].strip() == 'ARC':
                    #    print('Temporarily skipping OBSTYPE=ARC exposure {}/{}'.format(night, expid))
                    #    continue

                    #- submit batch jobs for others
                    cmd = '{basecall} -n {night} -e {exp}'.format(basecall=cmd_base,night=night,exp=expid)
                                         
                    print(cmd)
                    if args.dry_run:
                        print("\tOutput file would have been: {}".format(os.path.join(reduxdir,os.environ['SPECPROD'])))
                        print("\tCommand to be run: {}".format(cmd.split()))
                    else:
                        subprocess.call(cmd.split())
                    sys.stdout.flush()

                    #- Don't overwhelm the queue
                    nsubmit += 1
                    if nsubmit >= args.nsubmits:
                        break

                #- if we found any exposures, take a break after submitting
                #- them without checking prior nights to not overwhelm the queue
                break

        print('PID '+str(os.getpid())+' {} sleeping...'.format(time.asctime()))
        sys.stdout.flush()
        if args.dry_run:
            print("\n\n\tWould have paused for {} min. here, but this is a dry run. Continuing.\n".format(args.pausetime))
            time.sleep(4)
        else:
            time.sleep(args.pausetime*60)

if __name__=='__main__':
    args = parse(options=None)
    main(args)
