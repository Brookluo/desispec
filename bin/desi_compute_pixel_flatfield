#!/usr/bin/env python

import sys
import astropy.io.fits as pyfits
import argparse
import numpy as np
import scipy.signal
import numba

from desiutil.log import get_logger

import scipy.ndimage as ndi
from numba import cfunc, carray
from numba.types import intc, intp, float64, voidptr
from numba.types import CPointer
from scipy import LowLevelCallable

@cfunc(intc(CPointer(float64), intp,
            CPointer(float64), voidptr))
def maskedmed(values_ptr, len_values, result, data):
    values = carray(values_ptr, (len_values,), dtype=float64)
    ii=(values!=0)
    if np.sum(ii)>0 :
        result[0] = np.median(values[ii])
    else :
        result[0] = 0.
    return 1

def maskedmedian(image,size) :
    return ndi.generic_filter(image, LowLevelCallable(maskedmed.ctypes), size=size)




def clipped_mean_image(image_filenames) :
    """ Return a clipped mean of input images after rescaling each image

    Args:
        image_filenames : list of preprocessed image path

    Returns:
        mimage : mean image (2D np.array)
        ivar   : ivar of median
    """

    log.debug("first median")
    images=[]
    ivars=[]
    for filename in image_filenames  :
        h=pyfits.open(filename)
        images.append(h[0].data)
        ivars.append(h["IVAR"].data)

    mimage=np.median(images,axis=0)
    log.debug("compute a scale per image")
    smimage2=np.sum(mimage**2)
    for i in range(len(images)) :
        a=np.sum(images[i]*mimage)/smimage2
        log.debug("scale %d = %f"%(i,a))
        if a<=0 :
            raise ValueError("scale = %f for image %s"%(a,image_filenames[i]))
        images[i] /= a
        ivars[i] *= a**2
    
    shape=images[0].shape
    mimage=np.median(images,axis=0)

    log.info("compute mask ...")
    ares=np.abs(images-mimage)
    nsig=4.
    mask=(ares<nsig*1.4826*np.median(ares,axis=0))
    # average (not median)
    log.info("compute average ...")
    mimage=np.sum(images*mask,axis=0)/np.sum(mask,axis=0)
    mimage=mimage.reshape(shape)
    
    ivar=np.sum(ivars,axis=0)
    return mimage,ivar

@numba.jit
def dilate_mask(mask,d0=1,d1=1) :
    omask=mask.copy()
    n0=mask.shape[0]
    n1=mask.shape[1]
    for i0 in range(n0) :
        for i1 in range(n1) :
            if mask[i0,i1] :
                v=mask[i0,i1]
                for j0 in range(max(0,i0-d0),min(n0,i0+d0+1)) :
                    for j1 in range(max(0,i1-d1),min(n1,i1+d1+1)) :
                        omask[j0,j1]=v
    return omask

def convolve2d(image,k,weight=None) :
    """ Return a 2D convolution of image with kernel k, optionally with a weight image

    Args:
        image : 2D np.array image
        k : 2D np.array kernel, each dimension must be odd and greater than 1
    Options:
        weight : 2D np.array of same shape as image
    Returns:
        cimage : 2D np.array convolved image of same shape as input image
    """
    if weight is not None :
        if weight.shape != image.shape :
            raise ValueError("weight and image should have same shape")
        sw=convolve2d(weight,k,None)
        swim=convolve2d(weight*image,k,None)
        return swim/(sw+(sw==0))

    if len(k.shape) != 2 or len(image.shape) != 2:
        raise ValueError("kernel and image should have 2 dimensions")
    for d in range(2) :
        if k.shape[d]<=1 or k.shape[d]-(k.shape[d]//2)*2 != 1 :
            raise ValueError("kernel dimensions should both be odd and >1, and input as shape %s"%str(k.shape))
    m0=k.shape[0]//2
    m1=k.shape[1]//2
    eps0=m0
    eps1=m1
    tmp=np.zeros((image.shape[0]+2*m0,image.shape[1]+2*m1))
    tmp[m0:-m0,m1:-m1]=image
    tmp[:m0+1,m1:-m1]=np.tile(np.median(image[:eps0,:],axis=0),(m0+1,1))
    tmp[-m0-1:,m1:-m1]=np.tile(np.median(image[-eps0:,:],axis=0),(m0+1,1))
    tmp[m0:-m0,:m1+1]=np.tile(np.median(image[:,:eps1],axis=1),(m1+1,1)).T
    tmp[m0:-m0,-m1-1:]=np.tile(np.median(image[:,-eps1:],axis=1),(m1+1,1)).T
    tmp[:m0,:m1]=np.median(tmp[:m0,m1])
    tmp[-m0:,:m1]=np.median(tmp[-m0:,m1])
    tmp[-m0:,-m1:]=np.median(tmp[-m0:,-m1-1])
    tmp[:m0,-m1:]=np.median(tmp[:m0,-m1-1])
    return scipy.signal.fftconvolve(tmp,k,"valid")

def gaussian_smoothing_1d_per_axis(image,ivar,sigma,npass=2,dxdy=0.,dydx=0.) :
    """Computes a smooth model of the input image using two
    1D convolution with a Gaussian kernel of parameter sigma.
    Can do several passes.

    Args:
        image : 2D array input image
        sigma : float number (>0)
        npass : integer number (>=1)

    Returns:
        model : 2D array image of same shape as image
    """

    log=get_logger()
    hw=int(3*sigma)
    tmp = image.copy()
    tmpivar = ivar.copy()
    model = np.ones(tmp.shape).astype(float)

    # single Gaussian profile
    u=(np.arange(2*hw+1)-hw)
    prof=np.exp(-u**2/sigma**2/2.)
    prof/=np.sum(prof)

    # two kernels along two axes
    #
    kernels=[]

    # axis 0
    if dxdy==0 :
        kernel=np.zeros((2*hw+1,3))
        kernel[:,1]=prof
        kernels.append(kernel)
    else :
        x=u*dxdy
        i=(x+0.5*(x>0)-0.5*(x<0)).astype(int)
        j=np.arange(2*hw+1)
        hwb=max(1,np.max(np.abs(i)))
        kernel=np.zeros((2*hw+1,2*hwb+1))
        kernel[j,i+hwb]=prof
        kernels.append(kernel)

    # axis 1
    if dydx==0 :
        kernel=np.zeros((3,2*hw+1))
        kernel[1,:]=prof
        kernels.append(kernel)
    else :
        y=u*dydx
        j=(y+0.5*(y>0)-0.5*(y<0)).astype(int)
        i=np.arange(2*hw+1)
        hwb=max(1,np.max(np.abs(j)))
        kernel=np.zeros((2*hwb+1,2*hw+1))
        kernel[j+hwb,i]=prof
        kernels.append(kernel)

    for p in range(npass) : # possibly do several passes
        for a in range(2) : # convolve in 1d on each axis
            #log.debug("p=%d a=%d"%(p,a))
            res=convolve2d(tmp,kernels[a],weight=tmpivar)
            model *= res
            tmpivar *= res**2 # ?
            #tmpivar *= tmp**2 # ?
            tmp /= (res+(res==0))


    if 0 : # add 2D smoothing (does not help)
        x=np.tile((np.arange(2*hw+1)-hw)/sigma,(2*hw+1,1))
        r2=x**2+x.T**2
        kernel2d=np.exp(-r2/2.)
        kernel2d/=np.sum(kernel2d)
        res = convolve2d(tmp,kernel2d,weight=tmpivar)
        model *= res

    return model

def filtering(flat,model,width,edge_width,gradmask,reverse_order=False) :

    log = get_logger()
    
    if not reverse_order :
        shape_1 = [width,1]
        shape_2 = [1,width]
    else :
        shape_1 = [1,width]
        shape_2 = [width,1]
        
    log.info("step 1")
    model *= scipy.signal.medfilt2d(flat,shape_1)
    flat  =  (ivar>0)*(model>minflat)*image/(model*(model>minflat)+(model<=minflat))
    flat  += (model<=minflat)|(ivar<=0)
    log.info("step 2")
    model *= scipy.signal.medfilt2d(flat,shape_2)
    flat  =  (ivar>0)*(model>minflat)*image/(model*(model>minflat)+(model<=minflat))
    flat  += (model<=minflat)|(ivar<=0)

    if edge_width>1 :
        if not reverse_order :
            shape_1 = [edge_width,1]
            shape_2 = [1,edge_width]
        else :
            shape_1 = [1,edge_width]
            shape_2 = [edge_width,1]
        log.info("step 3")
        tmp = scipy.signal.medfilt2d(flat,shape_1)
        model[gradmask] *= tmp[gradmask]
        flat  =  (ivar>0)*(model>minflat)*image/(model*(model>minflat)+(model<=minflat))
        flat  += (model<=minflat)|(ivar<=0)
        log.info("step 4")
        tmp = scipy.signal.medfilt2d(flat,shape_2)
        model[gradmask] *= tmp[gradmask]
        flat  =  (ivar>0)*(model>minflat)*image/(model*(model>minflat)+(model<=minflat))
        flat  += (model<=minflat)|(ivar<=0)
    return flat,model
    
    
def edge_medfilt2d(image,shape) :
    return scipy.signal.medfilt2d(image,shape)

def amplifier_matching(image) :

    log = get_logger()
    
    n0 = image.shape[0]
    n1 = image.shape[1]
    c0 = n0//2
    c1 = n1//2
    w=10
    lw=200

    vband_a = np.median(image[c0-lw:c0,c1-w:c1],axis=1)
    vband_b = np.median(image[c0-lw:c0,c1::c1+w],axis=1)
    rab = np.sqrt( np.median(vband_a/vband_b) / np.median(vband_b/vband_a) ) # to debias
    log.debug("a/b=",rab)
    image[:c0,:c1] /= np.sqrt(rab)
    image[:c0,c1:] *= np.sqrt(rab)

    vband_c = np.median(image[c0:c0+lw,c1-w:c1],axis=1)
    vband_d = np.median(image[c0:c0+lw,c1::c1+w],axis=1)
    rcd = np.sqrt( np.median(vband_c/vband_d) / np.median(vband_d/vband_c) ) # to debias
    log.debug("c/d=",rcd)
    image[c0:,:c1] /= np.sqrt(rcd)
    image[c0:,c1:] *= np.sqrt(rcd)

    hband_ab = np.median(image[c0-w:c0,lw:-lw],axis=0)
    hband_cd = np.median(image[c0:c0+w,lw:-lw],axis=0)
    rac = np.sqrt( np.median(hband_ab/hband_cd) / np.median(hband_cd/hband_ab) ) # to debias
    log.debug("a/c = b/d =",rac)
    image[:c0] /= np.sqrt(rac)
    image[c0:] *= np.sqrt(rac)



parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,
description="""Computes a pixel level flat field image from a set of preprocessed images obtained with the flatfield slit.
An average image is computed if several preprocessed images are given.
The method consists in iteratively dividing the image by a smoothed version of the same image, flat(n+1) = flat(n)/smoothing(flat(n)).
The smoothing consists in 1D median filtering along the wavelength dispersion axis or the fiber axis alternatively, with masking.
"""
)

parser.add_argument('-i','--images', type = str, nargs='*', default = None, required = True,
                    help = 'path to input preprocessed image fits files, or a single median image')
parser.add_argument('-o','--outfile', type = str, default = None, required = True,
                    help = 'output flatfield image filename')
parser.add_argument('--out-mean', type = str, default = None, required = False,
                    help = 'save median image')
parser.add_argument('-d','--debug', action = 'store_true', help="write a lot of debugging images")
parser.add_argument('--minflux',type = float, default=0.05,help="minimum flux fraction of median")
parser.add_argument('--maxerr',type = float, default=0.02,help="maximum error")




args = parser.parse_args()
log = get_logger()

if len(args.images) == 1 :
    log.info("read a single image")
    h=pyfits.open(args.images[0])
    image=h[0].data
    ivar=h["IVAR"].data
else :
    log.info("compute a clipped mean of the input images")
    image,ivar=clipped_mean_image(args.images)

if args.out_mean is not None :
    log.info("writing median image %s ..."%args.out_mean)
    h=pyfits.HDUList([pyfits.PrimaryHDU(image),pyfits.ImageHDU(ivar,name="IVAR")])
    h.writeto(args.out_mean,overwrite=True)

minflat=0.0001
nstep=12
step=0
width=201

if args.debug :
    pyfits.writeto("debug-image-before-amp-match.fits",image,overwrite=True)
    log.info("wrote debug-image-before-amp-match.fits")

step+=1; log.info("step {}/{} match amps".format(step,nstep))
amplifier_matching(image)
# amplifier_matching(image) # redo for debugging

if args.debug :
    pyfits.writeto("debug-image-amp-match.fits",image,overwrite=True)
    log.info("wrote debug-image-amp-match.fits")

minflux=0.1*np.median(image)
maxerr=0.015
err   = np.sqrt(1./(ivar+(ivar==0)))/(image*(image>0)+(image<=0)) 

# define mask0
############################################
y=[]
xmin=[]
xmax=[]

margin = 20 # don't change this one.
for j in range(err.shape[0]) :
    ii=np.where((err[j,margin:-margin]<args.maxerr)&(image[j,margin:-margin]>args.minflux))[0]+margin
    y.append(j)
    if len(ii)<3 :
        xmin.append(4000)
        xmax.append(0)
    else :
        xmin.append(ii[0])
        xmax.append(ii[-1])
        
x=[]
ymin=[]
ymax=[]
for i in range(err.shape[1]) :
    jj=np.where((err[:,i]<args.maxerr)&(image[:,i]>args.minflux))[0]
    x.append(i)
    if len(jj)<3 :
        ymin.append(4000)
        ymax.append(0)
    else :
        ymin.append(jj[0])
        ymax.append(jj[-1])
x=np.array(x)
ymin=np.array(ymin)
ymax=np.array(ymax)
y=np.array(y)
xmin=np.array(xmin)
xmax=np.array(xmax)


margin = 5 # add a margin
xmin += margin
xmax -= margin
ymin += margin
ymax -= margin

mask0=np.zeros(err.shape,dtype=int)
for j in range(mask0.shape[0]) :
    mask0[j,:xmin[j]+1]=1
    mask0[j,xmax[j]:]=1    
for i in range(mask0.shape[1]) :
    mask0[:ymin[i]+1,i]=1
    mask0[ymax[i]:,i]=1

if False :
    log.info("mask out corners")
    ############################################
    n0=mask0.shape[0]
    n1=mask0.shape[1]

    for c in [0,1,2,3] :
        # find first pixel with mask0=0
        nn=500
        if c == 0 :
            ii0=np.arange(nn,dtype=int)
            ii1=np.arange(nn,dtype=int)
        elif c == 1 :
            ii0=np.arange(nn,dtype=int)
            ii1=np.arange(n1-1,n1-nn-1,-1,dtype=int)
        elif c == 2 :
            ii0=np.arange(n0-1,n0-nn-1,-1,dtype=int)
            ii1=np.arange(n1-1,n1-nn-1,-1,dtype=int)
        else :
            ii0=np.arange(n0-1,n0-nn-1,-1,dtype=int)
            ii1=np.arange(nn,dtype=int)

        u=np.where(mask0[ii0,ii1]>0)[0][-1]
        i0=ii0[u]
        i1=ii1[u]
        m=width # we have to add a margin equal to the filtering width
        min_corner_size=0 # 201 # I need this anyway ... 
        if i0 < 500 :
            i0 += m
            i0 = max(i0,min_corner_size)
        else :
            i0 -= m
            i0 = min(i0,n0-min_corner_size)
        if i1 < 500 :
            i1 += m
            i1 = max(i1,min_corner_size)
        else :
            i1 -= m
            i1 = min(i1,n1-min_corner_size)

        if c == 0 :
            mask0[:i0,:i1] += 1
            #image[:i0,:i1] = image[i0,i1]
        elif c == 1 :
            mask0[:i0,i1:] += 1
            #image[:i0,i1:] = image[i0,i1]
        elif c == 2 :
            mask0[i0:,i1:] += 1
            #image[i0:,i1:] = image[i0,i1]
        else  :
            mask0[i0:,:i1] += 1
            #image[i0:,:i1] = image[i0,i1]
    ############################################

if args.debug :
    pyfits.writeto("debug-mask-0.fits",mask0,overwrite=True)
    log.info("wrote debug-mask-0.fits")
    pyfits.writeto("debug-image-0.fits",image,overwrite=True)
    log.info("wrote debug-image-0.fits")
    pyfits.writeto("debug-err.fits",err,overwrite=True)
    log.info("wrote debug-err.fits")

original_image = image.copy()
mask=(original_image<=10.)


step+=1; log.info("step {}/{} first model".format(step,nstep))

medspec=np.zeros(image.shape[0])
n0=image.shape[0]
n1=image.shape[1]
b1=n1//2-500
e1=n1//2+500
band=image[:,b1:e1].copy()
for loop in range(3) :
    medspec=np.median(band,axis=1)
    for i in range(band.shape[1]) :
        band[:,i] *= np.median(band[:,i]/medspec)
    medspec=np.median(band,axis=1)
# need to smooth
y=np.arange(n0)
sigma=4.
k=np.exp(-(y-n0/2.)**2/2./sigma**2)
k/=np.sum(k)
medspec=scipy.signal.fftconvolve(medspec,k,'same')

if False : # simple
    norm0 = np.sum(medspec*medspec)
    for i in range(n1):
        a = np.sum(image[:,i]*medspec)/norm0
        if a > 0.1 :
            image[:,i] /= (a*medspec)
            ivar[:,i] *= (a*medspec)**2
        else :
            image[:,i] = 1.
            ivar[:,i]  = 0.

if False : # does not work either ....
    model = np.zeros(image.shape)
    
    dy=(y-n0//2)/float(n0//2)
    dspecdy=np.interp(y,y+1.,medspec)-medspec
    
    #import matplotlib.pyplot as plt
    #plt.plot(medspec)
    #plt.plot(dspecdy)
    #plt.show()
    
    npar=7 # max deg = npar-2
    A=np.zeros((npar,npar))
    B=np.zeros(npar)
    H=np.zeros((npar,n0))
    
    w = np.median(ivar,axis=1)/np.median(image,axis=1)**2
    sqrtw = np.sqrt(w)
    H[0] = medspec
    for p in range(0,npar-1) :
        H[p+1] = dy**p*dspecdy
    sqwH = sqrtw*H
    A = sqwH.dot(sqwH.T)
    Ai = np.linalg.inv(A)
    param=np.zeros((n1,npar))
    for i in range(n1):
        B = sqwH.dot(sqrtw*image[:,i])
        param[i] = Ai.dot(B)
        if i%100 == 0 : log.debug(i,param[i])
    # now smooth params with polynomial
    x=(np.arange(n1)-n1//2)/(n1/2.)
    ii=np.where(param[:,0]>0.2)[0]


    #import matplotlib.pyplot as plt
    for p in range(npar) :
        #plt.plot(x[:],param[:,p],".",label="P{}".format(p))
        #plt.plot(x[ii],param[ii,p],".")
        param_pol=np.poly1d(np.polyfit(x[ii],param[ii,p],6))
        param[:,p]=param_pol(x)
        #plt.plot(x[ii],param[ii,p],".")
    #plt.legend()
    #plt.show()    

    # apply model
    for i in range(n1):
        if param[i,0]<0.1 :    
            image[:,i] = 1.
            ivar[:,i] = 0.
        else :
            spec = H.T.dot(param[i])
            model[:,i] = spec
            image[:,i] /= spec
            ivar[:,i] *= spec**2
    
if True : # complex fit is not working at all    
    # for each col, find max correlation

    model = np.zeros(image.shape)
    
    nc = 80
    norm = np.mean(medspec[nc:-nc]**2)
    
    offsets=np.zeros(n1)
    corrvals=np.zeros(n1)
    for i in range(n1):
        nc=90
        corr=np.zeros(nc)
        dy=np.arange(-2,nc-2).astype(int)
        for c in range(nc) :
            corr[c]=np.mean(medspec[nc:-nc]*image[nc+dy[c]:n0-nc+dy[c],i])/norm
        c=np.argmax(corr)
        offsets[i]  = dy[c]
        corrvals[i] = corr[c]
        if i%100 == 0 :
            log.debug(i,offsets[i],corrvals[i])


    margin=200
    x=np.arange(n1)
    ok=(corrvals>0.1)
    pol=np.poly1d(np.polyfit(x[ok],offsets[ok],4))
    
    #import matplotlib.pyplot as plt
    #plt.plot(x,offsets)
    #plt.plot(x[ok],offsets[ok])
    #plt.plot(x[ok],pol(x[ok]))
    #plt.show()

    #import matplotlib.pyplot as plt

    
    y=np.arange(n0)
    dy=(y-n0//2)/float(n0//2)
    

    for loop in range(1) :
        
        if loop==0 :
            npar=4
        else :
            npar=4
        A=np.zeros((npar,npar))
        B=np.zeros(npar)
        H=np.zeros((npar,n0))
        param=np.zeros((n1,npar))

        
        for i in range(n1):

            if not ok[i] :
                image[:,i] = 1    
                ivar[:,i]  = 0
                continue


            if loop==0 :
                spec=np.interp(y,y+pol(x[i]),medspec)
            else :
                spec=model[:,i]
            dspecdy=np.interp(y,y+1,spec)-spec
            # refit offset and scale.
            # model = a * spec + b * dspecdy + c * dy * dspecdy + ...
            H[0] = spec
            H[1] = spec*dy
            H[2] = spec*dy**2
            for p in range(npar-3) :
                H[p+3] = dy**p*dspecdy
            sqrtw = np.sqrt(ivar[:,i]) ### high weight for faint values
            sqwH = sqrtw*H
            A = sqwH.dot(sqwH.T)
            B = sqwH.dot(sqrtw*image[:,i])
            Ai = np.linalg.inv(A)
            param[i] = Ai.dot(B)
            if i%100 == 0 : log.debug(i,loop,param[i])

        # fit smooth params
        dx=(np.arange(n1)-n1//2)/(n1/2.)
        ii=np.where(ok)[0]
        for p in range(npar) :        
            param_pol=np.poly1d(np.polyfit(dx[ii],param[ii,p],6))
            param[:,p]=param_pol(dx)

        for i in range(n1):
            if not ok[i] :
                continue

            
            if loop==0 :
                spec=np.interp(y,y+pol(x[i]),medspec)
            else :
                spec=model[:,i]
            if True :
                # use exact transfo instead of derivatives
                # spec' = a*spec + pol(y)*dspecdy
                #       = a*spec(y')
                # y' = y + pol(dy)/a
                a  = param[i,0]
                yp = y.astype(float)
                for p in range(npar-1) :
                    yp += param[i,p-1]/a
                specp = a*np.interp(yp,y,spec)
            if 1 :
                # use the linear approximation
                dspecdy=np.interp(y,y+1,spec)-spec
                H[0] = spec
                for p in range(npar-1) :
                    H[p+1] = dy**p*dspecdy
                specpp = H.T.dot(param[i])

                if False and i==540 :
                    import matplotlib.pyplot as plt
                    plt.figure()
                    plt.subplot(1,2,1)
                    plt.plot(y,yp)
                    plt.subplot(1,2,2)
                    plt.plot(spec,":")
                    plt.plot(specpp)
                    plt.plot(specp,"--")
                    print("loop #{}".format(loop))
                    plt.show()
            
            model[:,i] = specp
    
    for i in range(n1):
        if not ok[i] : continue
        spec = model[:,i]
        image[:,i] /= spec
        ivar[:,i] *= spec**2
    
if args.debug :
    pyfits.writeto("debug-flat-{}.fits".format(step),image,overwrite=True)
    log.info("wrote debug-flat-{}.fits".format(step))
    pyfits.writeto("debug-model-{}.fits".format(step),model,overwrite=True)
    log.info("wrote debug-model-{}.fits".format(step))

step+=1; log.info("step {}/{} compute a gradient mask".format(step,nstep))
sig=100.
hw=int(3*sig)
x=np.tile(np.linspace(-hw,hw,2*hw+1),((2*hw+1),1))
k=np.exp(-(x**2+x.T**2)/2/sig**2)
k/=np.sum(k)                      
smodel=convolve2d(model,k)
flat=model/smodel
gradmask=(np.abs(flat-1)>0.1)
gradmask = dilate_mask(gradmask,30,30)
if args.debug :
    pyfits.writeto("debug-gradmask.fits",gradmask.astype(int),overwrite=True)
    log.info("wrote debug-gradmask.fits")

#sys.exit(12)

flat=image.copy()
model=np.ones(flat.shape)

edge_width = 21

step+=1; log.info("step {}/{} filtering".format(step,nstep))
flat,model = filtering(flat,model,width,edge_width,gradmask,False)

if args.debug :
    tmp=flat.copy()
    tmp=flat*(mask0==0)+(mask0!=0)
    pyfits.writeto("debug-flat-{}.fits".format(step),tmp,overwrite=True)
    log.info("wrote debug-flat-{}.fits".format(step))
    pyfits.writeto("debug-flat-nomask-{}.fits".format(step),flat,overwrite=True)
    log.info("wrote debug-flat-nomask-{}.fits".format(step))

flat2=image.copy()
model2=np.ones(flat.shape)

step+=1; log.info("step {}/{} reverse order filtering".format(step,nstep))
flat2,model2 = filtering(flat2,model2,width,0,gradmask,reverse_order=True)
if args.debug :
    pyfits.writeto("debug-flat2-reversed.fits",flat2,overwrite=True)
    log.info("wrote debug-flat2-reversed.fits")

nloop=3
for loop in range(nloop) :

    step+=1; log.info("step {}/{} masking pixels".format(step,nstep))
    #mask = (np.abs(flat-1)>(0.01+3*err))|(original_image<=10.)
    mask = (flat<1-(0.01+4*err))|(flat>1+(0.05+4*err))|(original_image<=10.)
    mask = dilate_mask(mask,1,1)
    
    if args.debug :
        pyfits.writeto("debug-mask-{}.fits".format(step),mask.astype(int),overwrite=True)
        log.info("wrote debug-mask-{}.fits".format(step))
    
    if loop == 0 :
        log.debug("reset after mask is computed")
        flat = image*(mask==0)+model2*(mask!=0)
        model=np.ones(flat.shape)
        if args.debug :
            pyfits.writeto("debug-reset-flat.fits",flat,overwrite=True)
            log.info("wrote debug-reset-flat.fits")
    
    #else :
    #    flat = image*(mask==0)+model*(mask!=0)    
    #model=np.ones(flat.shape)


    if loop > 0 :
        step+=1; log.info("step {}/{} gaussian smoothing".format(step,nstep))
        w = (mask==0).astype(float)
        model *= gaussian_smoothing_1d_per_axis(flat,w,50.,npass=2)
        flat  =  (ivar>0)*(model>minflat)*image/(model*(model>minflat)+(model<=minflat))
        flat  += ((model<=minflat)|(ivar<=0))
        if args.debug:
            tmp=flat.copy()
            tmp=flat*(mask0==0)+(mask0!=0)
            pyfits.writeto("debug-flat-{}.fits".format(step),tmp,overwrite=True)
            log.info("wrote debug-flat-{}.fits".format(step))
            pyfits.writeto("debug-flat-nomask-{}.fits".format(step),flat,overwrite=True)
            log.info("wrote debug-flat-nomask-{}.fits".format(step))

    if loop < nloop-1 :
        step+=1; log.info("step {}/{} filtering".format(step,nstep))
        if loop == 0 :
            flat,model=filtering(flat,model,width,edge_width,gradmask,False)
        else :
            model *= maskedmedian(flat*(mask==0),[width,1])
            flat  =  (ivar>0)*(model>minflat)*image/(model*(model>minflat)+(model<=minflat))
            flat  += ((model<=minflat)|(ivar<=0))
            model *= maskedmedian(flat*(mask==0),[1,width])
            flat  =  (ivar>0)*(model>minflat)*image/(model*(model>minflat)+(model<=minflat))
            flat  += ((model<=minflat)|(ivar<=0))
    
    if args.debug : 
        tmp=flat.copy()
        tmp=flat*(mask0==0)+(mask0!=0)
        pyfits.writeto("debug-flat-{}.fits".format(step),tmp,overwrite=True)
        log.info("wrote debug-flat-{}.fits".format(step))
        pyfits.writeto("debug-flat-nomask-{}.fits".format(step),flat,overwrite=True)
        log.info("wrote debug-flat-nomask-{}.fits".format(step))
        pyfits.writeto("debug-model-{}.fits".format(step),model,overwrite=True)
        log.info("wrote debug-model-{}.fits".format(step))

fivar=ivar*model**2
flat[flat>1.2]=1.2
flat=flat*(mask0==0)+(mask0!=0)
fivar*=(mask0==0)

h=pyfits.HDUList([pyfits.PrimaryHDU(flat),pyfits.ImageHDU(fivar,name="IVAR")])
h.writeto(args.outfile,overwrite="True")
log.info("wrote {}".format(args.outfile))

