#!/usr/bin/env python


import sys,string
import astropy.io.fits as pyfits
import argparse
import numpy as np
import scipy.signal
import specter.psf

from desiutil.log import get_logger

def grid_from_psf(filename) :
    try :
        psftype=pyfits.open(filename)[0].header["PSFTYPE"]
    except KeyError :
        psftype=""

    psf=None
    
    if psftype=="GAUSS-HERMITE" :
        psf=specter.psf.GaussHermitePSF(filename)
    elif psftype=="SPOTGRID" :
        psf=specter.psf.SpotGridPSF(filename)
    
    if psf is None :
        raise ValueError("cannot read PSFTYPE=%s"%psftype)
    
    # make a grid of points from this PSF
    x=[]
    y=[]
    f=[]
    w=[]
    wstep=200.
    waves=np.linspace(psf.wmin,psf.wmax,int((psf.wmax-psf.wmin)/wstep))
    fibers=np.arange(psf.nspec)
    for fiber in fibers :
        for wave in waves :
            tx,ty = psf.xy(fiber,wave)
            x.append(tx)
            y.append(ty)
            f.append(fiber)
            w.append(wave)
    
    x=np.array(x)
    y=np.array(y)
    dxdy=np.zeros(x.size).astype(float)
    dydx=np.zeros(x.size).astype(float)

    # use this grid of points to determine dx/dy along wave and dy/dx along fiber
    for fiber in fibers :
        mask=np.where(f==fiber)[0]
        tx=x[mask]
        ty=y[mask]
        i=np.argsort(ty)
        dx=np.gradient(tx[i])
        dy=np.gradient(ty[i])
        dxdy[mask[i]]=dx/dy
    
    for wave in waves :
        mask=np.where(w==wave)[0]
        tx=x[mask]
        ty=y[mask]
        i=np.argsort(tx)
        dx=np.gradient(tx[i])
        dy=np.gradient(ty[i])
        dydx[mask[i]]=dy/dx
    return x,y,dxdy,dydx

def median_image(image_filenames) :
    """ Return a median of input images after rescaling each image
    
    Args:
        image_filenames : list of preprocessed image path

    Returns:
        mimage : median image (2D np.array)
    """
    
    log.debug("first median")
    images=[]
    for filename in image_filenames  :
        h=pyfits.open(filename)
        images.append(h[0].data)
    mimage=np.median(images,axis=0)
    log.debug("compute a scale per image")
    smimage2=np.sum(mimage**2)
    for i in range(len(images)) :
        a=np.sum(images[i]*mimage)/smimage2
        log.debug("scale %d = %f"%(i,a))
        if a<=0 :
            raise ValueError("scale = %f for image %s"%(a,image_filenames[i]))
        images[i] /= a
    mimage=np.median(images,axis=0)
    return mimage

def add_margins_to_image(image,margin) :
    """ Adds a margin to the image with extrapolated values.
    This is needed for Gaussian smoothing using FFTs

    Args:
        image : 2D array input image of shape (n0,n1)
        margin : integer number >0
    
    Returns:
        larger : larger image of shape (n0+2*margin,n1*2*margin)
    """
    
    if margin<=0 :
        raise ValueError("margin must be >0")
    larger=np.zeros((image.shape[0]+2*margin,image.shape[1]+2*margin))
    larger[margin:-margin,margin:-margin]=image
    eps=10
    larger[:margin+1,margin:-margin]=np.tile(np.median(image[:eps,:],axis=0),(margin+1,1))
    larger[-margin-1:,margin:-margin]=np.tile(np.median(image[-eps:,:],axis=0),(margin+1,1))
    larger[margin:-margin,:margin+1]=np.tile(np.median(image[:,:eps],axis=1),(margin+1,1)).T
    larger[margin:-margin,-margin-1:]=np.tile(np.median(image[:,-eps:],axis=1),(margin+1,1)).T
    larger[:margin,:margin]=np.median(larger[:margin,margin])
    larger[-margin:,:margin]=np.median(larger[-margin:,margin])
    larger[-margin:,-margin:]=np.median(larger[-margin:,-margin-1])
    larger[:margin,-margin:]=np.median(larger[:margin,-margin-1])
    return larger

def gaussian_smoothing_1d_per_axis(image,sigma,npass=2,dxdy=0,dydx=0) :
    """Computes a smooth model of the input image using two
    1D convolution with a Gaussian kernel of parameter sigma. 
    Can do several passes.
    
    Args:
        image : 2D array input image
        sigma : float number (>0)
        npass : integer number (>=1) 
    
    Returns:
        model : 2D array image of same shape as image
    """
    
    log=get_logger()
    hw=int(3*sigma)
    tmp = add_margins_to_image(image,hw)
    model = np.ones(tmp.shape)

    # single Gaussian profile
    u=(np.arange(2*hw+1)-hw)
    prof=np.exp(-u**2/sigma**2/2.)
    prof/=np.sum(prof)
    
    # two kernels along two axes
    # 
    kernels=[]

    # axis 0
    if dxdy==0 :
        kernel=np.zeros((2*hw+1,3))
        kernel[:,1]=prof
        kernels.append(kernel)
    else :
        # non trivial because of axis orientations
        dxmax=int(hw*np.abs(dxdy))+1
        n0=2*hw+1
        n1=2*dxmax+1
    
        x=u*dxdy
        x2d=np.tile(x,(n1,1)).T
        prof2d=np.tile(prof,(n1,1)).T
        v2d=np.tile(np.arange(n1)-dxmax,(n0,1))
        weight=1.-np.abs(x2d-v2d)
        weight*=(weight>0)
        kernel=prof2d*weight
        kernels.append(kernel)
    
    
    # axis 1
    if dydx==0 :
        kernel=np.zeros((3,2*hw+1))
        kernel[1,:]=prof
        kernels.append(kernel)
    else :
        dymax=int(hw*np.abs(dydx))+1
        n0=2*dymax+1
        n1=2*hw+1
    
        y=u*dydx
        y2d=np.tile(y,(n0,1))
        prof2d=np.tile(prof,(n0,1))
        v2d=np.tile(np.arange(n0)-dymax,(n1,1)).T
        weight=1.-np.abs(y2d-v2d)
        weight*=(weight>0)
        kernel=prof2d*weight
        kernels.append(kernel)
    
    
    for p in range(npass) : # possibly do several passes
        for a in range(2) : # convolve in 1d on each axis
            log.debug("p=%d a=%d"%(p,a))
            res=scipy.signal.fftconvolve(tmp,kernels[a],"same")
            model *= res
            tmp /= (res+(res==0))
    return model[hw:-hw,hw:-hw]
    
def gaussian_smoothing_1d_with_tilted_axes(image,sigma,npass,x,y,dxdy,dydx,nblocks=5) :
    """Computes a smooth model of the input image using two
    1D convolution with a Gaussian kernel of parameter sigma. 
    Can do several passes.
    
    Args:
        image : 2D array input image
        sigma : float number (>0)
        npass : integer number (>=1) 
    
    Returns:
        model : 2D array image of same shape as image
    """
    if x is None or nblocks==1 :
        return gaussian_smoothing_1d_per_axis(image,sigma,npass=npass,dxdy=0,dydx=0)
    
    # defining blocks where trace directions are averaged
    b0size=image.shape[0]//nblocks
    b1size=image.shape[1]//nblocks
    
    b0=b0size*np.arange(nblocks)
    e0=b0+b0size
    e0[-1]=image.shape[0]
    b1=b1size*np.arange(nblocks)
    e1=b1+b1size
    e1[-1]=image.shape[1]
    
    # average trace direction per block
    bdxdy=np.zeros((nblocks,nblocks))
    bdydx=np.zeros((nblocks,nblocks))
    for i in range(nblocks) :
        for j in range(nblocks) :
            mask=(y>b0[i])&(y<=e0[i])&(x>b1[j])&(x<=e1[j])
            
            if np.sum(mask)>0 :                
                bdxdy[i,j]=np.mean(dxdy[mask])
                bdydx[i,j]=np.mean(dydx[mask])
            
            log.debug("Block %d,%d n psf points=%d dxdy=%f dydx=%f"%(i,j,np.sum(mask),bdxdy[i,j],bdydx[i,j]))
    
    model=np.zeros(image.shape)
    for i in range(nblocks) :
        for j in range(nblocks) : 
            # fast, but with edge issues
            #model[b0[i]:e0[i],b1[j]:e1[j]] = gaussian_smoothing_1d_per_axis(image[b0[i]:e0[i],b1[j]:e1[j]],sigma,npass=npass,dxdy=bdxdy[i,j],dydx=bdydx[i,j])
            # slower, but without edge issues
            model = gaussian_smoothing_1d_per_axis(image,sigma,npass=npass,dxdy=bdxdy[i,j],dydx=bdydx[i,j])[b0[i]:e0[i],b1[j]:e1[j]]
            
    return model
    

def gaussian_smoothing_2d(image,sigma) :
    """Computes a smooth model of the input image using one
    2D convolution with a 2D Gaussian kernel of parameter sigma. 
    
    Args:
        image : 2D array input image
        sigma : float number (>0)
    
    Returns:
        model : 2D array image of same shape as image
    """
    hw=int(3*sigma)
    tmp = add_margins_to_image(image,hw)
    model = np.ones(tmp.shape)
    
    x=np.tile((np.arange(2*hw+1)-hw)/sigma,(2*hw+1,1))
    r2=x**2+x.T**2    
    kernel=np.exp(-r2/2.)
    kernel/=np.sum(kernel)
    return scipy.signal.fftconvolve(tmp,kernel,"same")[hw:-hw,hw:-hw]

    
parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,
description="Compute a pixel level flat field image from a set of preprocessed images obtained with the pixel flatfield slit."
)

parser.add_argument('-i','--images', type = str, nargs='*', default = None, required = True,
                    help = 'path to input preprocessed image fits files, or a single median image')
parser.add_argument('-o','--outfile', type = str, default = None, required = True,
                    help = 'output flatfield image filename')
parser.add_argument('--sigma', type = int, default = 60 , required = False, 
                    help = "gaussian smoothing sigma (default is tuned on teststand data")
parser.add_argument('--out-median', type = str, default = None , required = False, help = "save output median image (for development)")
parser.add_argument('--psf', type = str, default = None , required = False, help = "use traces in this PSF to orient 1D convolutions")

args        = parser.parse_args()
log = get_logger()

if len(args.images) == 1 :
    log.info("read a single image")
    image=pyfits.open(args.images[0])[0].data
else :
    log.info("compute a median of the input images")
    image=median_image(args.images)

if args.psf :
    log.info("get trace coordinates from psf %s"%args.psf)
    x,y,dxdy,dydx=grid_from_psf(args.psf)
else :
    x=None
    y=None
    dxdy=None
    dydx=None

log.info("first gaussian smoothing")
model=gaussian_smoothing_1d_with_tilted_axes(image,args.sigma,2,x,y,dxdy,dydx)

nsloop=2
for sloop in range(nsloop) :
    log.info("compute mask using a temporary flat %d/%d"%(sloop,nsloop))
    flat=(model>0)*image/(model+(model==0))
    flat+=(model<=0)
    flaterr=np.sqrt(1.+model*(model>0))/(model+(model==0))
    rms=np.abs(flat-1)/flaterr
    srms=gaussian_smoothing_2d(rms,10.)
    mask=(srms>1.)|(rms>3.)
    log.info("number of masked pixels=%d"%np.sum(mask.astype(int)))
    if 1 :
        log.info("replace masked pixels by model %d/%d"%(sloop,nsloop))
        nloop=6
        for loop in range(nloop) :
            log.debug("pass %d/%d"%(loop,nloop))
            tmp_image=image*(mask==0)+model*(mask>0)
            model=gaussian_smoothing_1d_with_tilted_axes(tmp_image,args.sigma,1,x,y,dxdy,dydx)

if 0 :        
    log.info("last gaussian smoothing, per quadrant, to remove residual gain difference")
    n0=tmp_image.shape[0]//2
    n1=tmp_image.shape[1]//2
    model=np.zeros(tmp_image.shape)
    model[:n0,:n1]=gaussian_smoothing_1d_with_tilted_axes(tmp_image[:n0,:n1],args.sigma,2,x,y,dxdy,dydx)
    model[n0:,:n1]=gaussian_smoothing_1d_with_tilted_axes(tmp_image[n0:,:n1],args.sigma,2,x,y,dxdy,dydx)
    model[n0:,n1:]=gaussian_smoothing_1d_with_tilted_axes(tmp_image[n0:,n1:],args.sigma,2,x,y,dxdy,dydx)
    model[:n0,n1:]=gaussian_smoothing_1d_with_tilted_axes(tmp_image[:n0,n1:],args.sigma,2,x,y,dxdy,dydx)
else :
    log.info("last gaussian smoothing")
    model=gaussian_smoothing_1d_with_tilted_axes(tmp_image,args.sigma,2,x,y,dxdy,dydx)
    

flat=(model>0)*image/(model+(model==0))
flat+=(model<=0)


log.info("writing %s ..."%args.outfile)
h=pyfits.HDUList([pyfits.PrimaryHDU(flat),pyfits.ImageHDU(model,name="MODEL"),pyfits.ImageHDU(mask.astype(int),name="MODMASK")])
h[0].header["EXTNAME"]="FLAT"
h[0].header["KERNSIG"]=args.sigma
h.writeto(args.outfile,clobber=True)

if args.out_median is not None :
    log.info("writing median image %s ..."%args.out_median)
    pyfits.writeto(args.out_median,image,clobber=True)

log.info("done")

