#!/usr/bin/env python


import sys,string
import astropy.io.fits as pyfits
import argparse
import numpy as np
import scipy.signal
import specter.psf

from desiutil.log import get_logger

def grid_from_psf(filename) :
    try :
        psftype=pyfits.open(filename)[0].header["PSFTYPE"]
    except KeyError :
        psftype=""

    psf=None
    
    if psftype=="GAUSS-HERMITE" :
        psf=specter.psf.GaussHermitePSF(filename)
    elif psftype=="SPOTGRID" :
        psf=specter.psf.SpotGridPSF(filename)
    
    if psf is None :
        raise ValueError("cannot read PSFTYPE=%s"%psftype)
    
    # make a grid of points from this PSF
    x=[]
    y=[]
    f=[]
    w=[]
    wstep=200.
    waves=np.linspace(psf.wmin,psf.wmax,int((psf.wmax-psf.wmin)/wstep))
    fibers=np.arange(psf.nspec)
    for fiber in fibers :
        for wave in waves :
            tx,ty = psf.xy(fiber,wave)
            x.append(tx)
            y.append(ty)
            f.append(fiber)
            w.append(wave)
    
    x=np.array(x)
    y=np.array(y)
    dxdy=np.zeros(x.size).astype(float)
    dydx=np.zeros(x.size).astype(float)

    # use this grid of points to determine dx/dy along wave and dy/dx along fiber
    for fiber in fibers :
        mask=np.where(f==fiber)[0]
        tx=x[mask]
        ty=y[mask]
        i=np.argsort(ty)
        dx=np.gradient(tx[i])
        dy=np.gradient(ty[i])
        dxdy[mask[i]]=dx/dy
    
    for wave in waves :
        mask=np.where(w==wave)[0]
        tx=x[mask]
        ty=y[mask]
        i=np.argsort(tx)
        dx=np.gradient(tx[i])
        dy=np.gradient(ty[i])
        dydx[mask[i]]=dy/dx
    return x,y,dxdy,dydx

def median_image(image_filenames) :
    """ Return a median of input images after rescaling each image
    
    Args:
        image_filenames : list of preprocessed image path

    Returns:
        mimage : median image (2D np.array)
    """
    
    log.debug("first median")
    images=[]
    for filename in image_filenames  :
        h=pyfits.open(filename)
        images.append(h[0].data)
    mimage=np.median(images,axis=0)
    log.debug("compute a scale per image")
    smimage2=np.sum(mimage**2)
    for i in range(len(images)) :
        a=np.sum(images[i]*mimage)/smimage2
        log.debug("scale %d = %f"%(i,a))
        if a<=0 :
            raise ValueError("scale = %f for image %s"%(a,image_filenames[i]))
        images[i] /= a
    mimage=np.median(images,axis=0)
    return mimage

def convolve2d(image,k) :
    
    if len(k.shape) != 2 or len(image.shape) != 2:
        raise ValueError("kernel and image should have 2 dimensions")
    for d in range(2) :
        if k.shape[d]<=1 or k.shape[d]-(k.shape[d]//2)*2 != 1 :
            raise ValueError("kernel dimensions should both be odd and >1, and input as shape %s"%str(k.shape))
    m0=k.shape[0]//2
    m1=k.shape[1]//2
    eps0=m0
    eps1=m1
    tmp=np.zeros((image.shape[0]+2*m0,image.shape[1]+2*m1))
    tmp[m0:-m0,m1:-m1]=image
    tmp[:m0+1,m1:-m1]=np.tile(np.median(image[:eps0,:],axis=0),(m0+1,1))
    tmp[-m0-1:,m1:-m1]=np.tile(np.median(image[-eps0:,:],axis=0),(m0+1,1))
    tmp[m0:-m0,:m1+1]=np.tile(np.median(image[:,:eps1],axis=1),(m1+1,1)).T
    tmp[m0:-m0,-m1-1:]=np.tile(np.median(image[:,-eps1:],axis=1),(m1+1,1)).T
    tmp[:m0,:m1]=np.median(tmp[:m0,m1])
    tmp[-m0:,:m1]=np.median(tmp[-m0:,m1])
    tmp[-m0:,-m1:]=np.median(tmp[-m0:,-m1-1])
    tmp[:m0,-m1:]=np.median(tmp[:m0,-m1-1])
    return scipy.signal.fftconvolve(tmp,k,"valid")

def gaussian_smoothing_1d_per_axis(image,sigma,npass=2,dxdy=0.,dydx=0.) :
    """Computes a smooth model of the input image using two
    1D convolution with a Gaussian kernel of parameter sigma. 
    Can do several passes.
    
    Args:
        image : 2D array input image
        sigma : float number (>0)
        npass : integer number (>=1) 
    
    Returns:
        model : 2D array image of same shape as image
    """
    
    log=get_logger()
    hw=int(3*sigma)
    tmp = image.copy()
    model = np.ones(tmp.shape).astype(float)

    # single Gaussian profile
    u=(np.arange(2*hw+1)-hw)
    prof=np.exp(-u**2/sigma**2/2.)
    prof/=np.sum(prof)
    
    # two kernels along two axes
    # 
    kernels=[]

    # axis 0
    if dxdy==0 :
        kernel=np.zeros((2*hw+1,3))
        kernel[:,1]=prof
        kernels.append(kernel)
    else :
        x=u*dxdy
        i=(x+0.5*(x>0)-0.5*(x<0)).astype(int)
        j=np.arange(2*hw+1)
        hwb=max(1,np.max(np.abs(i)))
        kernel=np.zeros((2*hw+1,2*hwb+1))
        kernel[j,i+hwb]=prof
        kernels.append(kernel)
    
    # axis 1
    if dydx==0 :
        kernel=np.zeros((3,2*hw+1))
        kernel[1,:]=prof
        kernels.append(kernel)
    else :
        y=u*dydx
        j=(y+0.5*(y>0)-0.5*(y<0)).astype(int)
        i=np.arange(2*hw+1)
        hwb=max(1,np.max(np.abs(j)))
        kernel=np.zeros((2*hwb+1,2*hw+1))
        kernel[j+hwb,i]=prof
        kernels.append(kernel)
    
    for p in range(npass) : # possibly do several passes
        for a in range(2) : # convolve in 1d on each axis
            #log.debug("p=%d a=%d"%(p,a))
            res=convolve2d(tmp,kernels[a])
            model *= res
            tmp /= (res+(res==0))

    if 1 : # add 2D smoothing (does not help)
        x=np.tile((np.arange(2*hw+1)-hw)/sigma,(2*hw+1,1))
        r2=x**2+x.T**2    
        kernel2d=np.exp(-r2/2.)
        kernel2d/=np.sum(kernel2d)
        res = convolve2d(tmp,kernel2d)
        model *= res
    
    return model

    
def gaussian_smoothing_1d_with_tilted_axes(image,sigma,npass,x,y,dxdy,dydx,nblocks=5) :
    """Computes a smooth model of the input image using two
    1D convolution with a Gaussian kernel of parameter sigma. 
    Can do several passes.
    
    Args:
        image : 2D array input image
        sigma : float number (>0)
        npass : integer number (>=1) 
    
    Returns:
        model : 2D array image of same shape as image
    """
    if x is None or nblocks==1 :
        return gaussian_smoothing_1d_per_axis(image,sigma,npass=npass,dxdy=0,dydx=0)
    
    
    # defining blocks where trace directions are averaged
    b0size=image.shape[0]//nblocks
    b1size=image.shape[1]//nblocks
    
    # blocks begin and end coordinates
    b0=b0size*np.arange(nblocks)
    e0=b0+b0size
    e0[-1]=image.shape[0]
    b1=b1size*np.arange(nblocks)
    e1=b1+b1size
    e1[-1]=image.shape[1]
    
    # blocks begin and end coordinates with margins
    hw=int(3*sigma)
    b0m = b0-hw    
    e0m = e0+hw
    b1m = b1-hw
    e1m = e1+hw
    b0m[b0m<0]=0
    e0m[e0m>image.shape[0]]=image.shape[0]
    b1m[b1m<0]=0
    e1m[e1m>image.shape[1]]=image.shape[1]
    
    
    # average trace direction per block
    bdxdy=np.zeros((nblocks,nblocks))
    bdydx=np.zeros((nblocks,nblocks))
    for i in range(nblocks) :
        for j in range(nblocks) :
            mask=(y>b0[i])&(y<=e0[i])&(x>b1[j])&(x<=e1[j])
            
            if np.sum(mask)>0 :                
                bdxdy[i,j]=np.mean(dxdy[mask])
                bdydx[i,j]=np.mean(dydx[mask])
            
            #log.debug("Block %d,%d n psf points=%d dxdy=%f dydx=%f"%(i,j,np.sum(mask),bdxdy[i,j],bdydx[i,j]))
    
    model=np.zeros(image.shape)
    for i in range(nblocks) :
        for j in range(nblocks) :
            log.info("calling gaussian_smoothing_1d_per_axis for block (%d,%d)"%(i,j))
            block_sigma = sigma
            if False :
                if (i==0 and j==0) or (i==0 and j==(nblocks-1)) or  (i==(nblocks-1) and j==(nblocks-1)) or (i==(nblocks-1) and j==0) :
                    block_sigma = sigma/2.
                    log.info("Using lower sigma for edge blocks (%d,%d) = %f"%(i,j,block_sigma))
            
            model[b0[i]:e0[i],b1[j]:e1[j]] = gaussian_smoothing_1d_per_axis(image[b0m[i]:e0m[i],b1m[j]:e1m[j]],sigma=block_sigma,npass=npass,dxdy=bdxdy[i,j],dydx=bdydx[i,j])[b0[i]-b0m[i]:,b1[j]-b1m[j]:][:e0[i]-b0[i],:e1[j]-b1[j]]
    
    return model
    

def gaussian_smoothing_2d(image,sigma) :
    """Computes a smooth model of the input image using one
    2D convolution with a 2D Gaussian kernel of parameter sigma. 
    
    Args:
        image : 2D array input image
        sigma : float number (>0)
    
    Returns:
        model : 2D array image of same shape as image
    """
    hw=int(3*sigma)
    x=np.tile((np.arange(2*hw+1)-hw)/sigma,(2*hw+1,1))
    r2=x**2+x.T**2    
    kernel=np.exp(-r2/2.)
    kernel/=np.sum(kernel)
    return convolve2d(image,kernel)

    
parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,
description="""Computes a pixel level flat field image from a set of preprocessed images obtained with the flatfield slit.
A median image is computed if several preprocessed images are given. 
The method consists in iteratively dividing the median or input image by a smoothed version of the same image, flat(n+1) = flat(n)/smoothing(flat(n)).
The smoothing consists in 1D FFT Gaussian convolution along the wavelength dispersion axis or the fiber axis alternatively. A masking of outliers is performed to avoid tails around CCD defects. The trace orientations is obtained from an input PSF file, and the orientations are averaged in blocks (the number of blocks is a parameter). Optionally the modeling can be performed per CCD amplifier to correct for gain mismatch (possibly due to non-linearities). The method fails in areas where the illumination pattern varies in both directions at a scale smaller than the sigma value, but the sigma value is also limited by the maximum size of the CCD defects to be captured in the flat.
"""
)

parser.add_argument('-i','--images', type = str, nargs='*', default = None, required = True,
                    help = 'path to input preprocessed image fits files, or a single median image')
parser.add_argument('-o','--outfile', type = str, default = None, required = True,
                    help = 'output flatfield image filename')
parser.add_argument('--sigma', type = int, default = 60 , required = False, 
                    help = "gaussian smoothing sigma (default is tuned on teststand data)")
parser.add_argument('--npass1', type = int, default = 2 , required = False, 
                    help = "number of iterations in gaussian smoothing 1")
parser.add_argument('--npass2', type = int, default = 6 , required = False, 
                    help = "number of iterations in gaussian smoothing 2")
parser.add_argument('--nblocks', type = int, default = 4 , required = False, 
                    help = "number of blocks along one axis (total number of blocks is the square) where the trace orientations are averaged (to use in combination with --psf option otherwise ignored)")
parser.add_argument('--out-median', type = str, default = None , required = False, help = "save output median image (for development)")
parser.add_argument('--psf', type = str, default = None , required = False, help = "use traces in this PSF to orient 1D convolutions")
parser.add_argument('--per-amplifier', action = 'store_true', default = None , required = False, help = "solve model per amplifier if gains are uncertain or non-linarities")

args        = parser.parse_args()
log = get_logger()

if len(args.images) == 1 :
    log.info("read a single image")
    image=pyfits.open(args.images[0])[0].data
else :
    log.info("compute a median of the input images")
    image=median_image(args.images)

if args.psf :
    log.info("get trace coordinates from psf %s"%args.psf)
    x,y,dxdy,dydx=grid_from_psf(args.psf)
else :
    x=None
    y=None
    dxdy=None
    dydx=None



log.info("first gaussian smoothing")
model=gaussian_smoothing_1d_with_tilted_axes(image,sigma=args.sigma,npass=args.npass1,x=x,y=y,dxdy=dxdy,dydx=dydx,nblocks=args.nblocks)

nsloop=2
for sloop in range(nsloop) :
    log.info("compute mask using a temporary flat %d/%d"%(sloop+1,nsloop))
    
    log.info("estimate variance")
    r_model=model.ravel()
    ok=(r_model>-100)&(r_model<5000)
    h0,bins=np.histogram(r_model[ok],bins=15)
    hx,junk=np.histogram(r_model[ok],weights=r_model[ok],bins=bins)
    valid=np.where(h0>50)[0]# cut on min number of pixels per flux bin
    if valid.size < 4 :
        log.warning("cannot measure variance, use guess")
        var = 1.+model*(model>0)
    else :
        flux=hx[valid]/h0[valid]
        var_of_flux=np.zeros(valid.size)
        r_res=image.ravel()-r_model
        for i,j in enumerate(valid) :
            var_of_flux[i] = (1.48*np.median(np.abs(r_res[(r_model>=bins[j])&(r_model<bins[j+1])])))**2
        c=np.polyfit(flux,var_of_flux,1)
        var = c[0]*model+c[1]
        log.info("var = %f + %f*flux"%(c[1],c[0]))
        if c[1]<1. :
            c[1]=1
            log.warning("forcing var(flux=0)=%f"%c[1])
        #import matplotlib.pyplot as plt
        #pol=np.poly1d(c)
        #err = var_of_flux*np.sqrt(2./h0[valid])
        #plt.errorbar(flux,var_of_flux,err,fmt="o")
        #plt.plot(flux,pol(flux),"-")
        #plt.show()
    
    flat=(model>0)*image/(model+(model==0))
    flat+=(model<=0)
    flaterr=np.sqrt(var)/(model+(model==0))
    rms=np.abs(flat-1)/flaterr
    srms=gaussian_smoothing_2d(rms,10.)
    mask=(srms>1.)|(rms>3.)
    
    # remove from mask regions with important model gradient
    grad=np.zeros(model.shape)
    grad[1:-1]=np.abs(model[2:]-model[:-2])
    grad[:,1:-1]+=np.abs(model[:,2:]-model[:,:-2])
    grad/=(model+(model==0))
    mask[grad>0.2]=0
    
    # do not mask edges
    mask[0,:]=0 ; mask[:,0]=1 ; mask[-1,:]=1 ; mask[:,-1]=1
    if args.per_amplifier :
        log.info("do not mask amp. boundaries")
        mask[image.shape[0]//2-2:image.shape[0]//2+3]=0
        mask[:,image.shape[1]//2-2:image.shape[1]//2+3]=0
    
    
    

    # DEBUG
    pyfits.writeto("mask-%d.fits"%sloop,mask.astype(int),clobber=True)
    pyfits.writeto("tmp-flat-%d.fits"%sloop,flat,clobber=True)
    
    log.info("number of masked pixels=%d"%np.sum(mask.astype(int)))
    if 1 :
        log.info("replace masked pixels by model %d/%d"%(sloop+1,nsloop))
        for loop in range(args.npass2) :
            log.debug("pass %d/%d"%(loop+1,args.npass2))
            tmp_image=image*(mask==0)+model*(mask>0)
            model=gaussian_smoothing_1d_with_tilted_axes(tmp_image,sigma=args.sigma,npass=1,x=x,y=y,dxdy=dxdy,dydx=dydx,nblocks=args.nblocks)

if args.per_amplifier :        
    log.info("last gaussian smoothing, per quadrant, to remove residual gain difference")
    n0=tmp_image.shape[0]//2
    n1=tmp_image.shape[1]//2
    model=np.zeros(tmp_image.shape)
    if args.nblocks == 1 :
        nblocks=1
    else :
        nblocks=args.nblocks//2
    model[:n0,:n1]=gaussian_smoothing_1d_with_tilted_axes(tmp_image[:n0,:n1],sigma=args.sigma,npass=args.npass1,x=x,y=y,dxdy=dxdy,dydx=dydx,nblocks=nblocks)
    model[n0:,:n1]=gaussian_smoothing_1d_with_tilted_axes(tmp_image[n0:,:n1],sigma=args.sigma,npass=args.npass1,x=x,y=y-n0,dxdy=dxdy,dydx=dydx,nblocks=nblocks)
    model[n0:,n1:]=gaussian_smoothing_1d_with_tilted_axes(tmp_image[n0:,n1:],sigma=args.sigma,npass=args.npass1,x=x-n1,y=y-n0,dxdy=dxdy,dydx=dydx,nblocks=nblocks)
    model[:n0,n1:]=gaussian_smoothing_1d_with_tilted_axes(tmp_image[:n0,n1:],sigma=args.sigma,npass=args.npass1,x=x-n1,y=y,dxdy=dxdy,dydx=dydx,nblocks=nblocks)
else :
    log.info("last gaussian smoothing (not per quadrant)")
    model=gaussian_smoothing_1d_with_tilted_axes(tmp_image,sigma=args.sigma,npass=args.npass1,x=x,y=y,dxdy=dxdy,dydx=dydx,nblocks=args.nblocks)
    



flat=(model>0)*image/(model+(model==0))
flat+=(model<=0)


log.info("writing %s ..."%args.outfile)
h=pyfits.HDUList([pyfits.PrimaryHDU(flat),pyfits.ImageHDU(model,name="MODEL"),pyfits.ImageHDU(mask.astype(int),name="MODMASK")])
h[0].header["EXTNAME"]="FLAT"
h[0].header["KERNSIG"]=args.sigma
h.writeto(args.outfile,clobber=True)

if args.out_median is not None :
    log.info("writing median image %s ..."%args.out_median)
    pyfits.writeto(args.out_median,image,clobber=True)

log.info("done")

