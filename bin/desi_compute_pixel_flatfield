#!/usr/bin/env python

import astropy.io.fits as pyfits
import argparse
import numpy as np
import scipy.signal
import numba

from desiutil.log import get_logger

def clipped_mean_image(image_filenames) :
    """ Return a clipped mean of input images after rescaling each image

    Args:
        image_filenames : list of preprocessed image path

    Returns:
        mimage : mean image (2D np.array)
        ivar   : ivar of median
    """

    log.debug("first median")
    images=[]
    ivars=[]
    for filename in image_filenames  :
        h=pyfits.open(filename)
        images.append(h[0].data)
        ivars.append(h["IVAR"].data)

    mimage=np.median(images,axis=0)
    log.debug("compute a scale per image")
    smimage2=np.sum(mimage**2)
    for i in range(len(images)) :
        a=np.sum(images[i]*mimage)/smimage2
        log.debug("scale %d = %f"%(i,a))
        if a<=0 :
            raise ValueError("scale = %f for image %s"%(a,image_filenames[i]))
        images[i] /= a
        ivars[i] *= a**2
    
    shape=images[0].shape
    mimage=np.median(images,axis=0)

    log.info("compute mask ...")
    ares=np.abs(images-mimage)
    nsig=4.
    mask=(ares<nsig*1.4826*np.median(ares,axis=0))
    # average (not median)
    log.info("compute average ...")
    mimage=np.sum(images*mask,axis=0)/np.sum(mask,axis=0)
    mimage=mimage.reshape(shape)
    
    ivar=np.sum(ivars,axis=0)
    return mimage,ivar

@numba.jit
def dilate_mask(mask,d0=1,d1=1) :
    omask=mask.copy()
    n0=mask.shape[0]
    n1=mask.shape[1]
    for i0 in range(n0) :
        for i1 in range(n1) :
            if mask[i0,i1] :
                v=mask[i0,i1]
                for j0 in range(max(0,i0-d0),min(n0,i0+d0+1)) :
                    for j1 in range(max(0,i1-d1),min(n1,i1+d1+1)) :
                        omask[j0,j1]=v
    return omask




parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,
description="""Computes a pixel level flat field image from a set of preprocessed images obtained with the flatfield slit.
An average image is computed if several preprocessed images are given.
The method consists in iteratively dividing the image by a smoothed version of the same image, flat(n+1) = flat(n)/smoothing(flat(n)).
The smoothing consists in 1D median filtering along the wavelength dispersion axis or the fiber axis alternatively, with masking.
"""
)

parser.add_argument('-i','--images', type = str, nargs='*', default = None, required = True,
                    help = 'path to input preprocessed image fits files, or a single median image')
parser.add_argument('-o','--outfile', type = str, default = None, required = True,
                    help = 'output flatfield image filename')
parser.add_argument('--out-mean', type = str, default = None, required = False,
                    help = 'save median image')
parser.add_argument('-d','--debug', action = 'store_true', help="write a lot of debugging images")


args = parser.parse_args()
log = get_logger()

if len(args.images) == 1 :
    log.info("read a single image")
    h=pyfits.open(args.images[0])
    image=h[0].data
    ivar=h["IVAR"].data
else :
    log.info("compute a clipped mean of the input images")
    image,ivar=clipped_mean_image(args.images)

if args.out_mean is not None :
    log.info("writing median image %s ..."%args.out_mean)
    h=pyfits.HDUList([pyfits.PrimaryHDU(image),pyfits.ImageHDU(ivar,name="IVAR")])
    h.writeto(args.out_mean,overwrite=True)

minflat=0.0001
nstep=10
step=0
width=101

err   = np.sqrt(1./(ivar+(ivar==0)))/(image*(image>0)+(image<=0)) 
maxerr=0.02
xmin=[]
xmax=[]

margin=20
for j in range(err.shape[0]) :
    ii=np.where(err[j,margin:-margin]<maxerr)[0]+margin
    if len(ii)<3 : continue
    xmin.append(ii[0])
    xmax.append(ii[-1])
xmin=int(np.median(xmin)+15)
xmax=int(np.median(xmax)-15)

log.info("xmin xmax = {} {}".format(xmin,xmax))

x=[]
ymin=[]
ymax=[]
for i in range(err.shape[1]) :
    jj=np.where(err[:,i]<maxerr)[0]
    if len(jj)<3 : continue
    x.append(i)
    ymin.append(jj[0])
    ymax.append(jj[-1])
x=np.array(x)
ymin=np.array(ymin)
ymax=np.array(ymax)
ok=np.where((x>xmin)&(x<xmax))[0]
pymin=np.poly1d(np.polyfit(x[ok],ymin[ok],4))
pymax=np.poly1d(np.polyfit(x[ok],ymax[ok],4))

mask0=np.zeros(err.shape,dtype=int)
mask0[:,:xmin+1]=1
mask0[:,xmax:]=1
for i in range(err.shape[1]) :
    mask0[:int(pymin(i)+1),i]=1
    mask0[int(pymax(i)):,i]=1



if args.debug :
    pyfits.writeto("debug-mask-0.fits",mask0,overwrite=True)
    log.info("wrote debug-mask-0.fits")
    pyfits.writeto("debug-err.fits",err,overwrite=True)
    log.info("wrote debug-err.fits")


mask=(image<=10.)
flat=image.copy()
model=np.ones(flat.shape)

step+=1; log.info("step {}/{} vertical median filter".format(step,nstep))
model *= scipy.signal.medfilt2d(flat,[width,1])
flat  =  (ivar>0)*(model>minflat)*image/(model*(model>minflat)+(model<=minflat))
flat  += ((model<=minflat)|(ivar<=0)|(mask!=0))
 
step+=1; log.info("step {}/{} horizontal median filter".format(step,nstep))
model *= scipy.signal.medfilt2d(flat,[1,width])
flat  =  (ivar>0)*(model>minflat)*image/(model*(model>minflat)+(model<=minflat))
flat  += ((model<=minflat)|(ivar<=0)|(mask!=0))

if args.debug :
    tmp=flat.copy()
    tmp=flat*(mask0==0)+(mask0!=0)
    pyfits.writeto("debug-flat-{}.fits".format(step),tmp,overwrite=True)
    log.info("wrote debug-flat-{}.fits".format(step))


flat2=image.copy()
model2=np.ones(flat.shape)

step+=1; log.info("step {}/{} horizontal median filter (other way)".format(step,nstep))
model2 *= scipy.signal.medfilt2d(flat2,[1,width])
flat2  =  (ivar>0)*(model2>minflat)*image/(model2*(model2>minflat)+(model2<=minflat))
flat2  += ((model2<=minflat)|(ivar<=0)|(mask!=0))

step+=1; log.info("step {}/{} vertical median filter (other way)".format(step,nstep))
model2 *= scipy.signal.medfilt2d(flat2,[width,1])
flat2  =  (ivar>0)*(model2>minflat)*image/(model2*(model2>minflat)+(model2<=minflat))
flat2  += ((model2<=minflat)|(ivar<=0)|(mask!=0))

if args.debug :
    tmp=flat2.copy()
    tmp=flat2*(mask0==0)+(mask0!=0)
    pyfits.writeto("debug-flat-{}.fits".format(step),tmp,overwrite=True)
    log.info("wrote debug-flat-{}.fits".format(step))

for loop in range(1) :

    step+=1; log.info("step {}/{} mask".format(step,nstep))
    mask = (np.abs(flat-1)>(0.01+3*err))|(image<=10.)
    mask = dilate_mask(mask,2,2)
    
    if args.debug :
        pyfits.writeto("debug-mask-{}.fits".format(step),mask.astype(int),overwrite=True)
        log.info("wrote debug-mask-{}.fits".format(step))
        
    
    # reset after mask is computed
    flat = image*(mask==0)+model2*(mask!=0)
    model=np.ones(flat.shape)
    
    step+=1; log.info("step {}/{} vertical median filter".format(step,nstep))
    model *= scipy.signal.medfilt2d(flat,[width,1])
    flat  =  (ivar>0)*(model>minflat)*image/(model*(model>minflat)+(model<=minflat))
    flat  += ((model<=minflat)|(ivar<=0))
    
    step+=1; log.info("step {}/{} horizontal median filter".format(step,nstep))
    model *= scipy.signal.medfilt2d(flat,[1,width])
    flat  =  (ivar>0)*(model>minflat)*image/(model*(model>minflat)+(model<=minflat))
    flat  += ((model<=minflat)|(ivar<=0))
    
    if args.debug:
        tmp=flat.copy()
        tmp=flat*(mask0==0)+(mask0!=0)
        pyfits.writeto("debug-flat-{}.fits".format(step),tmp,overwrite=True)
        log.info("wrote debug-flat-{}.fits".format(step))
           


fivar=ivar*model**2
flat[flat>1.2]=1.2
flat=flat*(mask0==0)+(mask0!=0)
fivar*=(mask0==0)

h=pyfits.HDUList([pyfits.PrimaryHDU(flat),pyfits.ImageHDU(fivar,name="IVAR")])
h.writeto(args.outfile,overwrite="True")
log.info("wrote {}".format(args.outfile))

