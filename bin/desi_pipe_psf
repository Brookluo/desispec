#!/usr/bin/env python
#
# See top-level LICENSE.rst file for Copyright information
#
# -*- coding: utf-8 -*-

"""
Run the specex PSF estimation in parallel.
"""

from __future__ import absolute_import, division, print_function

comm = None
rank = 0
nproc = 1

try:
    from mpi4py import MPI
    comm = MPI.COMM_WORLD
    rank = comm.rank
    nproc = comm.size
except ImportError:
    print("mpi4py not found, using only one process")

import sys
import os
import numpy as np
import argparse
import re

import desispec.io as io
from desispec.log import get_logger
import desispec.pipeline as pipe


def main():
    parser = argparse.ArgumentParser( description='Run PSF estimation for a night of data using multiple processes.' )
    parser.add_argument( '--raw', required=False, default=None, help='raw data directory' )
    parser.add_argument( '--redux', required=False, default=None, help='output directory' )
    parser.add_argument( '--night', required=True, default=None, help='night (YYYYMMDD)' )
    parser.add_argument( '--expid', required=False, default=None, help='only process this exposure ID' )
    parser.add_argument( '--lamplines', required=True, default=None, help='lamp lines file to use' )
    parser.add_argument( '--bootcalib_r', required=True, default=None, help='R output of desi_bootcalib for trace first guess' )
    parser.add_argument( '--bootcalib_b', required=True, default=None, help='B output of desi_bootcalib for trace first guess' )
    parser.add_argument( '--bootcalib_z', required=True, default=None, help='Z output of desi_bootcalib for trace first guess' )

    args = parser.parse_args()

    log = get_logger()

    # If data directories are not given, get them from environment
    # variables.

    date = io.validate_night(args.night)

    rawdir = args.raw
    if rawdir is None:
        rawdir = io.rawdata_root()
    else:
        # We are overriding the raw data directory.
        # Set the correct environment variable so that
        # the I/O routines work.
        os.environ['DESI_SPECTRO_DATA'] = os.path.abspath(rawdir)
    rawdir = os.path.abspath(rawdir)

    specdir = args.redux
    if specdir is None:
        specdir = io.specprod_root()
    else:
        # We are overriding the raw data directory.
        # Set the correct environment variable so that
        # the I/O routines work.
        os.environ['DESI_SPECTRO_REDUX'] = os.path.abspath(specdir)
    specdir = os.path.abspath(specdir)

    if rank == 0:
        log.info("using raw data directory: {}".format(rawdir))
        log.info("using night {}".format(args.night))
        log.info("using spectro redux dir {}".format(specdir))

    # get the list of raw files
    if rank == 0:
        log.info("finding arc exposures")
    (expid, exptype, fibermap, fullraw) = pipe.find_raw(rawdir, args.night, simraw=args.simraw)
    if rank == 0:
        for ex in expid:
            if exptype[ex] == 'arc':
                log.info("  {:08d}".format(ex))

    # if requested, restrict the exposure list to a single ID
    if args.expid is not None:
        if rank == 0:
            log.info("processing ONLY exposure {}".format(args.expid))
        raw = {}
        raw[args.expid] = fullraw[args.expid]
    else:
        raw = fullraw

    bootcal = {}
    bootcal['r'] = args.bootcalib_r
    bootcal['b'] = args.bootcalib_b
    bootcal['z'] = args.bootcalib_z

    if rank == 0:
        log.info("computing specex tasks")
    [tasks_bundle, tasks_merge] = pipe.tasks_specex(expid, exptype, raw, args.lamplines, bootcal=bootcal)

    # do all the per-bundle tasks now

    if rank == 0:
        log.info("executing per-bundle PSF estimation")
    work = pipe.task_dist(tasks_bundle, nproc)
    pipe.subprocess_list(work[rank])

    # now wait for all processes to finish
    if comm is not None:
        comm.barrier()

    # do all the merging tasks

    if rank == 0:
        log.info("merging per-bundle PSFs")
    work = pipe.task_dist(tasks_merge, nproc)
    pipe.subprocess_list(work[rank])

    # now wait for all processes to finish
    if comm is not None:
        comm.barrier()



if __name__ == "__main__":
    main()

