#!/usr/bin/env python
# coding: utf-8

import os
import sys
import time
import argparse

import fitsio
import numpy as np
import pandas as pd

from desitarget.targetmask import desi_mask
from desitarget.targets import main_cmx_or_sv

from desiutil.log import get_logger
from desiutil.dust import SFDMap, ext_odonnell
from desitarget.io import desitarget_resolve_dec
# to correct the photometry
from speclite import filters

decamwise = filters.load_filters('decam2014-g', 'decam2014-r','decam2014-z', 'wise2010-W1', 'wise2010-W2')
bassmzlswise = filters.load_filters('BASS-g', 'BASS-r', 'MzLS-z','wise2010-W1', 'wise2010-W2')

log = get_logger()


def collect_argparser():
    parser = argparse.ArgumentParser(description="Compile the different QSO identifications to build the QSO catalog")

    parser.add_argument("--zbest", type=str, required=True,
                        help="zbest file containing the redrock zbest output")
    parser.add_argument("--mgii", type=str, required=True,
                        help="mgii file containing the mgii afterburner output")
    parser.add_argument("--qn", type=str, required=True,
                        help="qn file containing the qn afterburner (with new run of RR) output")

    parser.add_argument("--output", type=str, required=True,
                        help="output filename where the result of the MgII will be saved")

    parser.add_argument("--clobber", type=bool, required=False, default=True,
                        help="EXPAND (clobber=False) or OVERWRITE (clobber=True) the output file. By default clobber=True")


    return parser.parse_args()


def extract_info_from_fibermap(fibermap, index_sorted, dataframe, sel):
    """
    Extract information from the fibermap. We save: TARGETID, RA, DEC, DESI_TARGET, MASKBIT,
    r, g, z, W1, W2, TILE, LAST_NIGHT, PETAL, FIBER
    Args:
        fibermap:  fitsio hdu 'FIBERMAP' from zbest file
        index_sorted (int array): index to have fibermap[index_sorted] in the same order than zbest
                      it is built with the TARGETID increasing
                      --> IT IS HOW WE DECIDED TO FILL THE DATAFRAME MATCHING THE REDSHIFT FROM ZBEST
        dataframe: dataframe to fill with useful information extracted from the fibermap
        sel: mask to select which objects from the fibermap have to be saved. Order given by the zbest file
             --> need to apply [index_sorted][sel]
    Returns:
        QSO_cat (pandas dataframe): Dataframe containing all the information
    """

    def compute_grzW1W2(fibermap, index_sorted, sel):
        # Compute g, r, z, W1, w2 magnitudes corrected by the Milky Way transmission
        # Args:
        #     fibermap: fitsio hdu 'FIBERMAP' from zbest file
        #     index_sorted (int array): index to have fibermap[index_sorted] in the same order than zbest
        #                               it is built with the TARGETID increasing
        #     sel: mask to select which objects from the fibermap have to be saved.
        # Returns:
        #     g, r, z, W1, W2: magnitudes corrected

        north = (fibermap['TARGET_RA'][:][index_sorted][sel] > 80) & (fibermap['TARGET_RA'][:][index_sorted][sel] < 300 ) & (fibermap['TARGET_DEC'][:][index_sorted][sel] > desitarget_resolve_dec())

        gflux  = fibermap['FLUX_G'][:][index_sorted][sel]
        rflux  = fibermap['FLUX_R'][:][index_sorted][sel]
        zflux  = fibermap['FLUX_Z'][:][index_sorted][sel]
        W1flux  = fibermap['FLUX_W1'][:][index_sorted][sel]
        W2flux  = fibermap['FLUX_W2'][:][index_sorted][sel]

        RV = 3.1
        EBV =  fibermap['EBV'][:][index_sorted][sel]

        mw_transmission = np.array([10**(-0.4 * EBV[i] * RV * ext_odonnell(bassmzlswise.effective_wavelengths.value, Rv=RV)) if north[i]
                                    else 10**(-0.4 * EBV[i] * RV * ext_odonnell(decamwise.effective_wavelengths.value, Rv=RV)) for i in range(EBV.size)])

        with np.errstate(divide='ignore', invalid='ignore'):
            g = np.where( gflux>0,22.5-2.5*np.log10(gflux/mw_transmission[:, 0]), 0.)
            r = np.where( rflux>0,22.5-2.5*np.log10(rflux/mw_transmission[:, 1]), 0.)
            z = np.where( zflux>0,22.5-2.5*np.log10(zflux/mw_transmission[:, 2]), 0.)
            W1 = np.where( W1flux>0,22.5-2.5*np.log10(W1flux/mw_transmission[:, 3]), 0.)
            W2 = np.where( W2flux>0,22.5-2.5*np.log10(W2flux/mw_transmission[:, 4]), 0.)

        return g, r, z, W1, W2

    dataframe['TARGETID'] = fibermap['TARGETID'][:][index_sorted][sel]
    dataframe['RA'] = fibermap['TARGET_RA'][:][index_sorted][sel]
    dataframe['DEC'] = fibermap['TARGET_DEC'][:][index_sorted][sel]

    DESI_TARGET = main_cmx_or_sv(fibermap[:])[0][0]
    dataframe[DESI_TARGET] = fibermap[DESI_TARGET][:][index_sorted][sel]
    dataframe['MASKBITS'] = fibermap["MASKBITS"][:][index_sorted][sel]

    g, r, z, W1, W2 = compute_grzW1W2(fibermap, index_sorted, sel)
    dataframe['G_MAG'] = g
    dataframe['R_MAG'] = r
    dataframe['Z_MAG'] = z
    dataframe['W1_MAG'] = W1
    dataframe['W2_MAG'] = W2

    dataframe['TILE'] = fibermap['TILEID'][:][index_sorted][sel]
    last_night = np.zeros(sel.sum(), dtype=int)
    for i, targetid in enumerate(fibermap['TARGETID'][:][index_sorted][sel]):
        last_night[i] = np.max(fibermap['NIGHT'][:][fibermap['TARGETID'][:] == targetid])
    dataframe['LAST_NIGHT'] = last_night
    dataframe['PETAL'] = fibermap['PETAL_LOC'][:][index_sorted][sel]
    dataframe['FIBER'] = fibermap['FIBER'][:][index_sorted][sel]

    return dataframe


def select_qso_with_RR(zbest, fibermap, index_sorted, qn_cat):
    """
    Apply the selection based on Redrock when there is no discrepancy with QuasarNet
    or if the objects are not selected by QuasarNet.
    Args:
        zbest: fitsio hdu 'ZBEST' from zbest file
        fibermap:  fitsio hdu 'FIBERMAP' from zbest file
        index_sorted (int array): index to have fibermap[index_sorted] in the same order than zbest
                      it is built with the TARGETID increasing
        qn_cat: fitsio hdu 'QN+RR' from qn file
    Returns:
        QSO_cat (pandas dataframe): Dataframe containing all the information
    """

    # find which objects from zbest are in the qn_cat
    is_in_qn_cat = np.isin(zbest['TARGETID'][:], qn_cat['TARGETID'][:])

    # sel objects with SPECTYPE == QSO and |z_RR - z_QN| <= 0.05 or not QSO for QN.
    sel = (zbest['SPECTYPE'][:] == 'QSO')
    sel[is_in_qn_cat] &= ~qn_cat['IS_QSO_QN_NEW_RR'][:]

    QSO_cat = pd.DataFrame()
    QSO_cat = extract_info_from_fibermap(fibermap, index_sorted, QSO_cat, sel)

    QSO_cat.insert(3, 'Z', zbest['Z'][:][sel])
    QSO_cat.insert(4, 'ZERR', zbest['ZERR'][:][sel])
    QSO_cat.insert(5, 'SELECTION_METHOD', "sel:RR - z:RR")
    QSO_cat.insert(6, 'Z_QN', np.NaN)
    QSO_cat.insert(7, 'Z_RR_ini', np.NaN)

    return QSO_cat


def select_qso_with_RR_new_run_RR(zbest, fibermap, index_sorted, qn_cat):
    """
    Apply the selection based on Redrock when there is a discrepancy with QuasarNet
    Choosing the redshift found with a new run of Redrock with prior
    Args:
        zbest: fitsio hdu 'ZBEST' from zbest file
        fibermap:  fitsio hdu 'FIBERMAP' from zbest file
        index_sorted (int array): index to have fibermap[index_sorted] in the same order than zbest
                      it is built with the TARGETID increasing
        qn_cat: fitsio hdu 'QN+RR' from qn file
    Returns:
        QSO_cat (pandas dataframe): Dataframe containing all the information
    """
    # find which objects from zbest are in the qn_cat
    is_in_qn_cat = np.isin(zbest['TARGETID'][:], qn_cat['TARGETID'][:])

    # sel objects with SPECTYPE == QSO and QSO for QN with|z_RR - z_QN| > 0.05
    sel = (zbest['SPECTYPE'][:] == 'QSO') & is_in_qn_cat
    sel[is_in_qn_cat] &= qn_cat['IS_QSO_QN_NEW_RR'][:]

    sel_in_qn_cat = (qn_cat['SPECTYPE'][:] == 'QSO') & qn_cat['IS_QSO_QN_NEW_RR'][:]

    QSO_cat = pd.DataFrame()
    QSO_cat = extract_info_from_fibermap(fibermap, index_sorted, QSO_cat, sel)
    QSO_cat.insert(3, 'Z', qn_cat['Z_NEW'][:][sel_in_qn_cat])
    QSO_cat.insert(4, 'ZERR', qn_cat['ZERR_NEW'][:][sel_in_qn_cat])
    QSO_cat.insert(5, 'SELECTION_METHOD', "sel:RR - z:QN/RR")
    QSO_cat.insert(6, 'Z_QN', qn_cat['Z_QN'][:][sel_in_qn_cat])
    QSO_cat.insert(7, 'Z_RR_ini', zbest['Z'][:][sel])

    return QSO_cat


def select_qso_with_MgII(zbest, fibermap, index_sorted, mgii_cat):
    """
    Apply the selection based on the MgII fitter, keeping the redshift estimated by Redrock
    Args:
        zbest: fitsio hdu 'ZBEST' from zbest file
        fibermap:  fitsio hdu 'FIBERMAP' from zbest file
        index_sorted (int array): index to have fibermap[index_sorted] in the same order than zbest
                      it is built with the TARGETID increasing
        mgii_cat: fitsio hdu 'MGII' from mgii file
    Returns:
        QSO_cat (pandas dataframe): Dataframe containing all the information
    """
    # find which objects from zbest are in the qn_cat
    is_in_mgii_cat = np.isin(zbest['TARGETID'][:], mgii_cat['TARGETID'][:])

    # sel objects with SPECTYPE != QSO and selected by the MgII
    sel = (zbest['SPECTYPE'][:] != 'QSO') & is_in_mgii_cat
    sel[is_in_mgii_cat] &= mgii_cat['IS_QSO_MGII'][:]

    sel_in_mgii_cat = (mgii_cat['SPECTYPE'][:] != 'QSO') & mgii_cat['IS_QSO_MGII'][:]

    QSO_cat = pd.DataFrame()
    QSO_cat = extract_info_from_fibermap(fibermap, index_sorted, QSO_cat, sel)
    QSO_cat.insert(3, 'Z', mgii_cat['Z_RR'][:][sel_in_mgii_cat])
    QSO_cat.insert(4, 'ZERR', mgii_cat['ZERR'][:][sel_in_mgii_cat])
    QSO_cat.insert(5, 'SELECTION_METHOD', "sel:MgII - z:RR")
    QSO_cat.insert(6, 'Z_QN', np.NaN)
    QSO_cat.insert(7, 'Z_RR_ini', np.NaN)

    return QSO_cat


def select_qso_with_QN_new_run_RR(zbest, fibermap, index_sorted, qn_cat, targetid_already_selected_with_mgII):
    """
    Apply the selection based on QN with a new run of Redrock with prior
    Args:
        zbest: fitsio hdu 'ZBEST' from zbest file
        fibermap:  fitsio hdu 'FIBERMAP' from zbest file
        index_sorted (int array): index to have fibermap[index_sorted] in the same order than zbest
                      it is built with the TARGETID increasing
        qn_cat: fitsio hdu 'QN+RR' from qn file
        targetid_already_selected_with_mgII (int array): targetid already selected by the selection based on the MgII
    Returns:
        QSO_cat (pandas dataframe): Dataframe containing all the information
    """
    # find which objects from zbest are in the qn_cat
    is_in_qn_cat = np.isin(zbest['TARGETID'][:], qn_cat['TARGETID'][:])

    # find which targetid is already selected by the MgII fitter
    selected_by_mgii = np.isin(zbest['TARGETID'][:], targetid_already_selected_with_mgII)
    selected_by_mgii_in_qn_cat = np.isin(qn_cat['TARGETID'][:], targetid_already_selected_with_mgII)

    # sel objects with SPECTYPE != QSO and unselected by the MgII and selected by QN
    sel = (zbest['SPECTYPE'][:] != 'QSO') & is_in_qn_cat & ~selected_by_mgii
    sel[is_in_qn_cat] &= qn_cat['IS_QSO_QN_NEW_RR'][:]

    sel_in_qn_cat = (qn_cat['SPECTYPE'][:] != 'QSO') & qn_cat['IS_QSO_QN_NEW_RR'][:] & ~selected_by_mgii_in_qn_cat

    QSO_cat = pd.DataFrame()
    QSO_cat = extract_info_from_fibermap(fibermap, index_sorted, QSO_cat, sel)
    QSO_cat.insert(3, 'Z', qn_cat['Z_NEW'][:][sel_in_qn_cat])
    QSO_cat.insert(4, 'ZERR', qn_cat['ZERR_NEW'][:][sel_in_qn_cat])
    QSO_cat.insert(5, 'SELECTION_METHOD', "sel:QN - z:QN/RR")
    QSO_cat.insert(6, 'Z_QN', qn_cat['Z_QN'][:][sel_in_qn_cat])
    QSO_cat.insert(7, 'Z_RR_ini', zbest['Z'][:][sel])

    return QSO_cat


def save_dataframe_to_fits(dataframe, filename, clobber=True):
    """
    Save info from pandas dataframe in a fits file.
    Args:
        dataframe (pandas dataframe): dataframe containg the all the necessary QSO info
        filename (str):  name of the fits file
        clobber (bool):  overwrite the fits file defined by filename ?
    Returns:
        None
    """
    # No complex structure, to_records() is sufficient.
    fits = fitsio.FITS(filename, 'rw', clobber=clobber)
    if clobber:
        log.warning(f'OVERWRITE the file : {filename}')
    else:
        log.warning(f'EXPAND the file : {filename}')
    fits.write(dataframe.to_records())
    fits.close()


if __name__ == "__main__":
    start = time.time()

    args = collect_argparser()

    if os.path.isfile(args.zbest) & os.path.isfile(args.mgii) & os.path.isfile(args.qn):

        # load best fit info generated by redrock
        zbest_file = fitsio.FITS(args.zbest)
        zbest = zbest_file['ZBEST']
        fibermap = zbest_file['FIBERMAP']

        # in zbest targetid are sorted, it is not the case in the fibermap
        # sorted with unique and conserve only one iteration of each target
        index_sorted = np.unique(fibermap['TARGETID'][:], return_index=True)[1]
        log.info(f"SANITY CHECK: The index_sorted for fibermap gives the same TARGETIG "
               + f"in the same order than in zbest: {np.sum(zbest['TARGETID'][:] == fibermap['TARGETID'][:][index_sorted])} / {zbest['TARGETID'][:].size}")

        # load info from mgii
        mgii_cat = fitsio.FITS(args.mgii)['MGII']
        # load info from qn with new run of RR
        qn_cat = fitsio.FITS(args.qn)['QN+RR']

        # Apply the selection following the flowchart
        QSO_from_RR = select_qso_with_RR(zbest, fibermap, index_sorted, qn_cat)
        QSO_from_RR_with_QN = select_qso_with_RR_new_run_RR(zbest, fibermap, index_sorted, qn_cat)
        QSO_from_MgII = select_qso_with_MgII(zbest, fibermap, index_sorted, mgii_cat)
        QSO_from_QN = select_qso_with_QN_new_run_RR(zbest, fibermap, index_sorted, qn_cat, QSO_from_MgII['TARGETID'])

        # Concatene the different selection
        QSO_cat = pd.concat([QSO_from_RR, QSO_from_RR_with_QN, QSO_from_MgII, QSO_from_QN], ignore_index=True)
        log.info(f"Final selection gives: {QSO_cat.shape[0]} QSO with {(QSO_cat[main_cmx_or_sv(fibermap[:])[0][0]] & desi_mask.QSO != 0).sum()} DESI QSO targets")

        # close file !!
        zbest_file.close()

        # Save QSO catalog in a fits file
        save_dataframe_to_fits(QSO_cat, args.output, args.clobber)

    else: # file for the consider Tile / Night / petal does not exist
        log.error(f"There is problem with files: {args.zbest} or {args.mgii} or {args.qn}")

    log.info(f"EXECUTION TIME: {time.time() - start:3.2f} s.")
